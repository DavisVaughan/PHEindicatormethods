---
title: "Calculating DSRs using the PHEstatmethods package"
author: "Georgina Anderson"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette for calculating DSRs for multiple geographies using data from the Data Lake}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  error = TRUE,
  comment = "#>"
)
```

##DRAFT - Work in Progress



## Introduction
This vignette documents the requirements and method for calculating DSRs using the PHEstatmethods::phe_dsr function 
which calculates DSRs and their confidence limits using the Dobson method.


The function can be used to calculate DSRs for grouping single or multiple geographic areas and genders in a single execution.


The function takes the following arguments as inputs:

| Argument  | Type            | Definition                                                                |Default value  |
|:----------|:----------------|:--------------------------------------------------------------------------|:--------------|
| x         | numeric vector  | observed number of events for each standardisation category (eg ageband) within each grouping set (eg area)    | none          |
| n         | numeric vector  | populations for each standardisation category (eg ageband) within each grouping set (eg area)               | none          |
| stdpop    | numeric vector  | standard populations for each standardisation category (eg age band) the European Standard Population 2013 divided into 19 five-year agebands (0-4, 5-9, 10-14, .....90+) is available within the package and can be referenced using esp2013   | none          | 
| groupref  | character vector| grouping sets (eg area codes or area names) if calculating multiple DSRs at once      | "No Grouping" |
| conf.level| numeric value   | the required level of confidence expressed as a number between 0.9 and 1 or 90 and 100  | 0.95          |
| multiplier| numeric value   | the multiplier used to express the final values (eg 100,000 = rate per 100,000, 100 = percentage)                          | 100,000       |



## Libraries

```{r libraries, message=FALSE}
library(PHEstatmethods)
library(RODBC)
library(dplyr)
library(tidyr)
```


## First a few words of caution
* ensure that numeric vectors x, n and stdpop all contain an element for every possible combination of groupref  (eg area) and standardisation category (eg age group) - when there are no deaths in an age group the vector needs to hold a zero to represent this value
* ensure the vectors x and n are ordered by the same groupref (eg area) and ageband values
* ensure the standard population reference is ordered by the same ageband values.  Note that the stdpop vector does not need to be duplicated when data is being passed for multiple geographies as R will do that for you

## Now let's extract some data to play with

#### Define Connections to Data Lake
```{r define connection}
dbhandle1 <- odbcDriverConnect('driver={SQL Server};server=SQLClusColLake\\Lake;
database=z_Populations_DEV;Encrypt=true;trusted_connection=true')
dbhandle2 <- odbcDriverConnect('driver={SQL Server};server=SQLClusColLake\\Lake;
database=BirthsDeaths;Encrypt=true;trusted_connection=true')
```

#### Execute SQL queries and save results to R data frames
```{r Execute SQL Query and load results into r object}
pops <- sqlQuery(dbhandle1,"SELECT Period, OfficialCode as RGN09CD, GeoName as RGN09NM, 
QuinaryAgeBandMin as AgeBand, Population
FROM [z_Populations_DEV].[dbo].[vRes_RGN09_FiveYear]
WHERE OfficialCode in ('E12000001','E12000002','E12000003')
AND Period in ('2014','2015','2016')
AND Sex = 4
ORDER BY Period, OfficialCode, Sex, QuinaryAgeBandMin")

deaths <- sqlQuery(dbhandle2,"SELECT xYEAR as Period, RGN09CD, RGN09NM, 
       CASE WHEN xAge_Year>=90 THEN 90 ELSE FLOOR(CAST(LEFT(xAge_Year,2) AS FLOAT)/5)*5 END AS AgeBand, COUNT(*) AS Dths
FROM BirthsDeaths.dbo.vDeathsALL d
LEFT JOIN LookupsShared.dbo.vLKP_RGN09 l
ON d.GOR_Resi = l.RGN09CDO 
WHERE RGN09CD IN ('E12000001','E12000002','E12000003')
AND xYEAR in ('2014','2015','2016')
GROUP BY xYEAR, RGN09CD, RGN09NM, 
       CASE WHEN xAge_Year>=90 THEN 90 ELSE FLOOR(CAST(LEFT(xAge_Year,2) AS FLOAT)/5)*5 END
ORDER BY xYear, RGN09CD, AgeBand")
```

#### Close Data Lake Connections
```{r Close dbhandle}
odbcClose(dbhandle1)
odbcClose(dbhandle2)
```


## Next we'll check that our data frames meet the requirements for the function

#### Do we have the expected number of rows in each dataset?
We're expecting 3 geographies * 3 periods * 19 agebands = 171 records ....

```{r check number of rows}
nrow(pops) == 171
nrow(deaths) == 171
```

#### Are the rows aligned identically in each dataset?
``` {r check row alignments}
all.equal(select(pops,Period, RGN09CD, AgeBand),
             select(deaths,Period, RGN09CD, AgeBand), check.attributes=FALSE, check.names=FALSE)
```

#### Are the rows a repeating sequence of the required ageband categories? 
We'll be using the esp2013 vector that is provided with the PHEstatmethods package -
it contains 19 ordered values representing the 5-year age bands 0-4, 5-9, 10-14....90+
``` {r check repeats of stdpop}
all.equal(select(pops,4),
          data.frame(rep(c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90),times=9)),
          check.attributes=FALSE, check.names=FALSE)
```

#### Looks good.

## So let's calculate DSRs for each Period and Geography 
The function requires the grouping sets to be stored in a single column so first we'll need to concatenate
the values of the Period and Geography columns into a Group Reference column.

We can choose to leave the populations and deaths in separate data frames or combine them as below ....

#### Prepare the data frame

``` {r create reference column}
df <- full_join(pops,deaths, by = c("Period","RGN09CD","RGN09NM","AgeBand")) %>%
            mutate(group_ref = paste(Period,"_",RGN09CD)) %>%
            select(group_ref,AgeBand, Population, Dths)
```
 
#### Execute the function
 
Now we're ready to calculate the DSRs .... 
 
``` {r calculate DSR for NW 2016}
phe_dsr(df$Dths, df$Population,esp2013, groupref = df$group_ref)

```

## But what if the data are not so tidy?

#### Zero deaths for a specific age band within a small geography
This would be a fairly common scenario - maybe you have Local Authority data and there are no deaths in some of the younger age groups for some of the smaller areas.  

Let's fudge a couple of data frames to represent this.  In this example, there are no deaths in the 10-14, 15-20 and 20-14 age bands:

``` {r test data}
pops_zero <- data.frame(AgeBand = c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90),
                        Population = esp2013/100)
pops_zero

deaths_zero <- data.frame(AgeBand = c(0,5,25,30,35,40,45,50,55,60,65,70,75,80,85,90),
                          Dths    = c(1,1, 1, 1, 3, 3, 3, 3,10,10,10,10, 8, 8, 8, 8))
deaths_zero
```

If we simply provide this data to the phe_dsr function as it is then the function will produce an error as below:
``` {r error test}
phe_dsr(pops_zero$Population,deaths_zero$Dths,stdpop=esp2013)
```
The easiest way to prepare the data for input to our function is to join the datasets as shown below - by default the join puts an NA into the Dths column for the AgeBand rows where no deaths occurred so we need to force these to zeros in a separate statement.  (An alternative would be to pad out the Dths data frame but in this case you would need to ensure that the deaths remained ordered correctly by age band.) 

``` {r prep data}
data_zero <- left_join(pops_zero, deaths_zero, by="AgeBand") %>%
             mutate(Dths = replace(Dths, which(is.na(Dths)), 0))
```

Now if we provide this data to the phe_dsr function it will give a valid result as below:
``` {r dsr with zero deaths for age bands}
phe_dsr(data_zero$Dths,data_zero$Population,stdpop=esp2013)
```


