---
title: "Calculating DSRs using PHEstatmethods"
author: "Georgina Anderson"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    css: style.css
vignette: >
  %\VignetteIndexEntry{Vignette for calculating DSRs for multiple geographies and time periods using data from the Data Lake}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  error = TRUE,
  comment = "#>"
)
```

##DRAFT - Work in Progress



## Introduction
This vignette documents the method for calculating DSRs using the PHEstatmethods::phe_dsr function 
which calculates DSRs and their confidence limits using the Dobson method.


The function can be used to calculate DSRs for grouping single or multiple geographic areas/ genders/ timeperiods/ indicators in a single execution and takes the following arguments as inputs:

<br/>
<br/>


| Argument     | Type             | Definition                                                             |Default value  |
|:-------------|:-----------------|:-----------------------------------------------------------------------|:--------------|
| data         | data.frame       | data.frame containing the data to be standardised                      | none          |
| x            | unquoted string   | field name from data containing the observed number of events for each standardisation category (eg ageband) within each grouping set (eg area or indicator)    | none          |
| n            | unquoted string  | field name from data containing the populations for each standardisation category (eg ageband) within each grouping set (eg area or indicator)| none          |
| stdpop       | unquoted string  | standard populations for each standardisation category (eg age band) specified as a field name from data or a vector.    | esp2013         | 
| stdpoptype   | quoted string    | whether the stdpop argument has been specified as a vactor or a field name | "vector"      | 
| confidence   | numeric value    | the required level of confidence expressed as a number between 0.9 and 1 or 90 and 100  | 0.95          |
| multiplier   | numeric value    | the multiplier used to express the final values (eg 100,000 = rate per 100,000 | 100,000       |

<br/>
<br/>

Note that the European Standard Population 2013 divided into 19 five-year agebands (0-4, 5-9, 10-14, .....90+) is provided in vector format within the package and will be used as the default for the stdpop argument

If multiple DSRs are required from a single data frame then the data frame must be grouped prior to inputting to the function - this is demonstrated below 


#### The following packages must be installed and loaded if not already available

```{r libraries, message=FALSE}
library(PHEstatmethods)
library(RODBC)
library(dplyr)
library(rlang)
library(tidyr)
```


## First let's extract some data to play with

#### Define Connections to Data Lake
```{r define connection}
dbhandle1 <- odbcDriverConnect('driver={SQL Server};server=SQLClusColLake\\Lake;
database=z_Populations_DEV;Encrypt=true;trusted_connection=true')
dbhandle2 <- odbcDriverConnect('driver={SQL Server};server=SQLClusColLake\\Lake;
database=BirthsDeaths;Encrypt=true;trusted_connection=true')
```

#### Execute SQL queries and save results to R data frames
```{r Execute SQL Query and load results into r object}
pops <- sqlQuery(dbhandle1,"SELECT Period, OfficialCode as RGN09CD, GeoName as RGN09NM, 
QuinaryAgeBandMin as AgeBand, Population
FROM [z_Populations_DEV].[dbo].[vRes_RGN09_FiveYear]
WHERE OfficialCode in ('E12000001','E12000002','E12000003')
AND Period in ('2014','2015','2016')
AND Sex = 4
ORDER BY Period, OfficialCode, QuinaryAgeBandMin")

deaths <- sqlQuery(dbhandle2,"SELECT xYEAR as Period, RGN09CD, RGN09NM, 
       CASE WHEN xAge_Year>=90 THEN 90 ELSE FLOOR(CAST(LEFT(xAge_Year,2) AS FLOAT)/5)*5 END AS AgeBand, COUNT(*) AS Dths
FROM BirthsDeaths.dbo.vDeathsALL d
LEFT JOIN LookupsShared.dbo.vLKP_RGN09 l
ON d.GOR_Resi = l.RGN09CDO 
WHERE RGN09CD IN ('E12000001','E12000002','E12000003')
AND xYEAR in ('2014','2015','2016')
GROUP BY xYEAR, RGN09CD, RGN09NM, 
       CASE WHEN xAge_Year>=90 THEN 90 ELSE FLOOR(CAST(LEFT(xAge_Year,2) AS FLOAT)/5)*5 END
ORDER BY xYear, RGN09CD, AgeBand")
```

#### Close Data Lake Connections
```{r Close dbhandle}
odbcClose(dbhandle1)
odbcClose(dbhandle2)
```


## Now let's calculate a DSR for each period and geography combination

#### Prepare the data frame

First we'll need to join our datasets to create the input data.frame for the function and specify the grouping sets:

``` {r create reference column}
df <- left_join(pops,deaths, by = c("Period","RGN09CD","RGN09NM","AgeBand")) %>%
  group_by(Period, RGN09CD)
```
 

#### Caution: The order of your records is important!

The phe_dsr function has built in error handling to ensure that when the standard population is provided as a vector (stdpoptype="vector"), the data you provide 
contains the same number of records per group as the standard population you are using.  However, **it will assume that those records are provided in the same order in your data and in the standard population vector**.  For example if the standard population vector is sorted from highest ageband to lowest ageband but the data records are sorted from lowest ageband to highest ageband then the function will still provide a result but it will have incorrectly standardised the data and this may not be apparent to the user.  

In this example we'll use the esp2013 vector that is provided with the PHEstatmethods package for our standard population -
it contains 19 ordered values representing the 5-year age bands 0-4, 5-9, 10-14....85-89, 90+.

You can run code like this to check that you also have 19 records per group within your data.frame, but **you will also need to ensure that your data records are ordered to match the order of those in the standard population vector**:

``` {r check repeats of stdpop}
summarise(df,n=n())
```


#### Execute the function
 
Now we're ready to calculate the DSRs.  

By default the function will apply 95% confidence, a 100,000 multiplier and will output just 3 fields against each grouping set - the dsr, the lower confidence limit and the upper confidence limit: 
 
``` {r calculate DSRs}
phe_dsr(df, Dths, Population)
```

Alternatively, we can add further arguments to specify:

* the level of detail required in the output (type)
* the confidence level (confidence)
* the multiplier (multiplier)

``` {r alternative dsr}
phe_dsr(df, Dths, Population, type = "full", confidence = 99.8, multiplier = 10000)
```

## Specifying non-default Standard Populations

In some cases you may wish to standardise against a different population such as the 1976 European Standard Population or an age and sex standardised population.  There are two ways to specify an alternative standard population:

#### Provide the custom standard population as a vector
In the example below, the 1976 European Standard Population (which has 18 age groups) is provided as a vector and then referenced in the function call.  To ensure the function works we must also ensure that our data has been broken down into these same 18 age bands (for the purposes of this example I've just combined the 85-90 and 90+ age band data into a single 85+ age band from the data.frame we used earlier).  

The phe_dsr function can then be executed using a user-defined standard population:

``` {r specify stdpop as vector}
esp1976 <- c(8000,	7000,	7000,	7000,	7000,	7000,	7000,	7000,	7000,	7000,	7000,	6000,	5000,	4000,	3000,	2000,	1000,	1000)

df18 <- df
df18$Dths[df18$AgeBand == 85]       <- df18$Dths[df18$AgeBand == 85] + df18$Dths[df18$AgeBand == 90]
df18$Population[df18$AgeBand == 85] <- df18$Population[df18$AgeBand == 85] + df18$Population[df18$AgeBand == 90]
df18 <- filter(df18,AgeBand != 90)

phe_dsr(df18,Dths,Population,stdpop = esp1976)

```

#### Append the standard populations to your data frame before executing the function
In the example below, the esp2013 standard population is appended to our data frame prior to calling the phe_dsr function.  The field name can then be specified in the function call.  If stdpop is specified as a field name we must also tell the function this by specifying stdpoptype = "field" as below:

``` {r specify stdpop as field name}
df_with_stdpop <- mutate(df,spop = esp2013)
names(df_with_stdpop)
phe_dsr(df_with_stdpop, Dths, Population, stdpop = spop, stdpoptype = "field")

```

## But what if the data are not so tidy?

#### Zero deaths for a specific age band within a small geography
This would be a fairly common scenario - maybe you have Local Authority data and there are no deaths in some of the younger age groups for some of the smaller areas.  

Let's fudge a couple of data frames to represent this.  In this example, there are no deaths in the 10-14, 15-20 and 20-14 age bands:

``` {r test data}
pops2   <- data.frame(AgeBand    = c( 0, 5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90),
                      Population = c(30,35,35,35,40,40,45,50,50,50,60,60,70,75,70,60,20,20,15))

deaths2 <- data.frame(AgeBand = c(0,5,25,30,35,40,45,50,55,60,65,70,75,80,85,90),
                      Dths    = c(1,1, 1, 1, 3, 3, 3, 3,10,10,10,10, 8, 8, 8, 8))
```

If we simply join these data frames to produce the input data frame required for the phe_dsr function then we get NA values in the Deaths column and the function will return an error:

``` {r error test}
df2 <- left_join(pops2, deaths2, by="AgeBand")
phe_dsr(df2, Dths, Population)
```

The NA values must be replaced with zeros before executing the function: 

``` {r prep data}
df3 <- df2 %>%
        mutate(Dths = replace(Dths, which(is.na(Dths)), 0))
phe_dsr(df3, Dths, Population)
```
