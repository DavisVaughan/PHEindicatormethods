mutate(mean = total / numrecs,
lowercl = mean - abs(qt(0.025, numrecs - 1)) * stdev / sqrt(numrecs),
uppercl = mean + abs(qt(0.025, numrecs - 1)) * stdev / sqrt(numrecs),
method = "t-distribution") %>%
select(1,2,3,5,4,6,7)
# set column names
names(phe_mean) <- c("row label","value_sum","value_count","mean","stdev",
paste("lower",conf.level*100,"cl",sep=""),
paste("upper",conf.level*100,"cl",sep=""),"method")
return(phe_proportion)
}
test_Mean         <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean",    col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Results", col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean_Results", col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean_results", col_names=TRUE)
View(test_Mean)
View(test_Mean_results)
test_Mean$Area         <- as.factor(test_Mean$Area)
test_Mean_Results$Area <- as.factor(test_Mean_results$Area)
test_Mean$Area         <- as.factor(test_Mean$Area)
test_Mean_results$Area <- as.factor(test_Mean_results$Area)
test_Mean$area         <- as.factor(test_Mean$area)
test_Mean_results$area <- as.factor(test_Mean_results$area)
View(test_Mean)
test_Mean         <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean",         col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean_results", col_names=TRUE)
test_Mean$area         <- as.factor(test_Mean$area)
test_Mean_results$area <- as.factor(test_Mean_results$area)
# use this code to save loaded data to sysdata folder:
devtools::use_data(test_Prop_1, test_Prop_100,
test_Rate_100, test_Rate_100000,
test_Mean, test_Mean_results,
test_DSR_multiarea, test_DSR_1976, test_DSR_err1, test_DSR_err2, test_DSR_err3, test_DSR_results,
test_ISR_multiarea, test_ISR_refdata, test_ISR_err1, test_ISR_err2, test_ISR_err3, test_ISR_results,
internal = TRUE, overwrite = TRUE)
data.frame(phe_mean(test_Mean$values)
)
phe_mean <- function(x, groupref = "No grouping", conf.level=0.95) {
# validate arguments - copied from proportion need editing
#  if (any(x < 0)) {
#    stop("numerators must be greater than or equal to zero")
#  } else if (any(n <= 0)) {
#    stop("denominators must be greater than zero")
#  } else if (any(x > n)) {
#    stop("numerators must be less than or equal to denominator for a proportion statistic")
#  } else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
#    stop("confidence level must be between 90 and 100 or between 0.9 and 1")
#  } else if (length(x) != length(n)) {
#    stop("numerator and denominator vectors must be of equal length")
#  }
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate proportion and CIs
phe_mean <- data.frame(x, groupref) %>%
group_by(groupref) %>%
summarise(total   = sum(x),
numrecs = length(x),
stdev   = sd(x)) %>%
mutate(mean = total / numrecs,
lowercl = mean - abs(qt(0.025, numrecs - 1)) * stdev / sqrt(numrecs),
uppercl = mean + abs(qt(0.025, numrecs - 1)) * stdev / sqrt(numrecs),
method = "t-distribution") %>%
select(1,2,3,5,4,6,7)
# set column names
names(phe_mean) <- c("row label","value_sum","value_count","mean","stdev",
paste("lower",conf.level*100,"cl",sep=""),
paste("upper",conf.level*100,"cl",sep=""),"method")
return(phe_proportion)
}
ata.frame(phe_mean(test_Mean$values))
data.frame(phe_mean(test_Mean$values))
phe_mean <- data.frame(x, groupref) %>%
group_by(groupref) %>%
summarise(total   = sum(x),
numrecs = length(x),
stdev   = sd(x)) %>%
mutate(mean = total / numrecs,
lowercl = mean - abs(qt(0.025, numrecs - 1)) * stdev / sqrt(numrecs),
uppercl = mean + abs(qt(0.025, numrecs - 1)) * stdev / sqrt(numrecs),
method = "t-distribution")
phe_mean
# create phe_proportion function to execute binom.confint with method fixed to wilson
phe_mean <- function(x, groupref = "No grouping", conf.level=0.95) {
# validate arguments - copied from proportion need editing
#  if (any(x < 0)) {
#    stop("numerators must be greater than or equal to zero")
#  } else if (any(n <= 0)) {
#    stop("denominators must be greater than zero")
#  } else if (any(x > n)) {
#    stop("numerators must be less than or equal to denominator for a proportion statistic")
#  } else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
#    stop("confidence level must be between 90 and 100 or between 0.9 and 1")
#  } else if (length(x) != length(n)) {
#    stop("numerator and denominator vectors must be of equal length")
#  }
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate proportion and CIs
phe_mean <- data.frame(x, groupref) %>%
group_by(groupref) %>%
summarise(total   = sum(x),
numrecs = length(x),
stdev   = sd(x)) %>%
mutate(mean = total / numrecs,
lowercl = mean - abs(qt(0.025, numrecs - 1)) * stdev / sqrt(numrecs),
uppercl = mean + abs(qt(0.025, numrecs - 1)) * stdev / sqrt(numrecs),
method = "t-distribution") %>%
select(1,2,3,5,4,6,7,8)
# set column names
names(phe_mean) <- c("row label","value_sum","value_count","mean","stdev",
paste("lower",conf.level*100,"cl",sep=""),
paste("upper",conf.level*100,"cl",sep=""),"method")
return(phe_proportion)
}
data.frame(phe_mean(test_Mean$values))
phe_mean <- function(x, groupref = "No grouping", conf.level=0.95) {
# validate arguments - copied from proportion need editing
#  if (any(x < 0)) {
#    stop("numerators must be greater than or equal to zero")
#  } else if (any(n <= 0)) {
#    stop("denominators must be greater than zero")
#  } else if (any(x > n)) {
#    stop("numerators must be less than or equal to denominator for a proportion statistic")
#  } else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
#    stop("confidence level must be between 90 and 100 or between 0.9 and 1")
#  } else if (length(x) != length(n)) {
#    stop("numerator and denominator vectors must be of equal length")
#  }
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate proportion and CIs
phe_mean <- data.frame(x, groupref) %>%
group_by(groupref) %>%
summarise(total   = sum(x),
numrecs = length(x),
stdev   = sd(x)) %>%
mutate(mean = total / numrecs,
lowercl = mean - abs(qt(0.025, numrecs - 1)) * stdev / sqrt(numrecs),
uppercl = mean + abs(qt(0.025, numrecs - 1)) * stdev / sqrt(numrecs),
method  = "t-distribution") %>%
select(1,2,3,5,4,6,7,8)
# set column names
names(phe_mean) <- c("row label","value_sum","value_count","mean","stdev",
paste("lower",conf.level*100,"cl",sep=""),
paste("upper",conf.level*100,"cl",sep=""),"method")
return(phe_mean)
}
data.frame(phe_mean(test_Mean$values))
data.frame(phe_dsr(test_DSR_multiarea$count,
test_DSR_multiarea$pop,
stdpop = esp2013,
groupref=test_DSR_multiarea$area,
multiplier=10000)[1:6])
View(test_Mean_results)
test_Mean         <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean",         col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean_results", col_names=TRUE)
test_Mean$area         <- as.factor(test_Mean$area)
test_Mean_results$area <- as.factor(test_Mean_results$area)
data.frame(phe_mean(test_Mean$values))
filter(test_Mean_results,group == "No grouping")
View(test_Mean_results)
filter(test_Mean_results,area == "No grouping")
expect_equal(data.frame(phe_mean(test_Mean$values))[1:7],
select(filter(test_Mean_results,area == "No grouping"),1:7),
check.attributes=FALSE, check.names=FALSE,info="test1")
data.frame(phe_mean(test_Mean$values,groupref = area))[1:7]
data.frame(phe_mean(test_Mean$values,groupref = test_Mean$area))[1:7]
select(filter(test_Mean_results,area != "No grouping"),1:7)
expect_equal(data.frame(phe_mean(test_Mean$values))[1:7],
select(filter(test_Mean_results,area == "No grouping"),1:7),
check.attributes=FALSE, check.names=FALSE,info="test1")
expect_equal(data.frame(phe_mean(test_Mean$values,groupref = test_Mean$area))[1:7],
select(filter(test_Mean_results,area != "No grouping"),1:7),
check.attributes=FALSE, check.names=FALSE,info="test1")
phe_mean(c(-2,0,2,4,5))
# -------------------------------------------------------------------------------------------------
#' Calculates a mean with confidence limits using students-t distribution method.
#'
#' @param x the observed values in the sample(s)/population(s); numeric vector; no default
#' @param groupref the grouping sets (eg area codes or area names) if calculating multiple means at once,
#'                 character vector, default = No Grouping
#' @param conf.level the required level of confidence expressed as a number between 0.9 and 1
#'                   or 90 and 100; numeric; default 0.95
#'
#' @return Returns a data frame of row labels, sum of values, count of values, mean, standard deviation,
#'         lower and upper confidence limits and method
#'
#' @examples
#' phe_mean(c(20,30,40), 0.95)
#'
#' @import dplyr
#'
#' @export
#'
#' @family phe statistical functions
#' @seealso \code{\link{phe_proportion}} for proportions,
#'          \code{\link{phe_rate}} for rates,
#'          \code{\link{phe_mean}} for means,
#'          \code{\link{phe_dsr}} for directly standardised rates,
#'          \code{\link{phe_isr}} for indirectly standardised ratios/rates and standardised mortality ratios
# -------------------------------------------------------------------------------------------------
# create phe_proportion function to execute binom.confint with method fixed to wilson
phe_mean <- function(x, groupref = "No grouping", conf.level=0.95) {
# validate arguments - copied from proportion need editing
if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate proportion and CIs
phe_mean <- data.frame(x, groupref) %>%
group_by(groupref) %>%
summarise(total   = sum(x),
numrecs = length(x),
stdev   = sd(x)) %>%
mutate(mean = total / numrecs,
lowercl = mean - abs(qt(0.025, numrecs - 1)) * stdev / sqrt(numrecs),
uppercl = mean + abs(qt(0.025, numrecs - 1)) * stdev / sqrt(numrecs),
method  = "t-distribution") %>%
select(1,2,3,5,4,6,7,8)
# set column names
names(phe_mean) <- c("row_label","value_sum","value_count","mean","stdev",
paste("lower",conf.level*100,"cl",sep=""),
paste("upper",conf.level*100,"cl",sep=""),"method")
return(phe_mean)
}
expect_error(data.frame(phe_mean(test_Mean$values,conf.level=12))[1:7],
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error test 1")
data.frame(phe_mean(test_Mean$values,conf.level=12))[1:7]
devtools::document()
library(PHEstatmethods)
library(dplyr)
library(testthat)
library(devtools)
library(binom)
library(readxl)
devtools::document()
devtools::test()
expect_equal(data.frame(phe_mean(test_Mean$values))[1:7],
select(filter(test_Mean_results,area == "No grouping"),1:7),
check.attributes=FALSE, check.names=FALSE,info="test1")
expect_equal(data.frame(phe_mean(test_Mean$values,groupref = test_Mean$area))[1:7],
select(filter(test_Mean_results,area != "No grouping"),1:7),
check.attributes=FALSE, check.names=FALSE,info="test2")
expect_error(data.frame(phe_mean(test_Mean$values,conf.level=12)),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error test 1")
test_that("means and CIs calculate correctly",{
expect_equal(data.frame(phe_mean(test_Mean$values))[1:7],
select(filter(test_Mean_results,area == "No grouping"),1:7),
check.attributes=FALSE, check.names=FALSE,info="test1")
expect_equal(data.frame(phe_mean(test_Mean$values,groupref = test_Mean$area))[1:7],
select(filter(test_Mean_results,area != "No grouping"),1:7),
check.attributes=FALSE, check.names=FALSE,info="test2")
})
data.frame(phe_mean(test_Mean$values))[1:7]
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
arg_defs <- data.frame(c("x","n","stdpop","groupref","conf.level","multiplier"),
c("a numeric vector containing the observed number of events for each
standardisation category (eg ageband) within each grouping set (eg area)",
"a numeric vector containing the populations for each standardisation
category (eg ageband) within each grouping set (eg area)",
"a numeric vector containing the standard populations for each standardisation category
(eg age band); numeric vector; no default; the European Standard Population 2013
divided into 19 five-year agebands (0-4, 5-9, 10-14, .....90+) is available within
the package and can be referenced using esp2013",
"the grouping sets (eg area codes or area names) if calculating multiple DSRs at once,
character vector, default = No Grouping",
"the required level of confidence expressed as a number between 0.9 and 1
or 90 and 100; numeric; default 0.95",
"the multiplier used to express the final values (eg 100,000 = rate per 100,000,
100 = percentage); numeric; default 100,000"))
knitr::kable(data, caption = "Table of Arguments")
library(fingertipsR)
region <- "North East region"
top_names <- c("England", region)
dfdom <- fingertips_data(DomainID = 8000037) %>%
group_by(IndicatorID) %>%
filter(TimeperiodSortable == max(TimeperiodSortable) &
Sex == "Persons" &
(AreaName %in% top_names |
ParentName == region)) %>%
ungroup() %>%
mutate(Value = round(Value, 1))
library(dplyr)
region <- "North East region"
top_names <- c("England", region)
dfdom <- fingertips_data(DomainID = 8000037) %>%
group_by(IndicatorID) %>%
filter(TimeperiodSortable == max(TimeperiodSortable) &
Sex == "Persons" &
(AreaName %in% top_names |
ParentName == region)) %>%
ungroup() %>%
mutate(Value = round(Value, 1))
)
dfdom <- fingertips_data(DomainID = 8000037) %>%
group_by(IndicatorID) %>%
filter(TimeperiodSortable == max(TimeperiodSortable) &
Sex == "Persons" &
(AreaName %in% top_names |
ParentName == region)) %>%
ungroup() %>%
mutate(Value = round(Value, 1))
View(dfdom)
rm(dfdom)
rm(top_names)
rm(region)
3 * 3 * 19
3 * 2* 3 * 19
deaths <- sqlQuery(dbhandle,"SELECT xYEAR, RGN09CD, RGN09NM, Sex,
CASE WHEN xAge_Year>=90 THEN 90 ELSE FLOOR(CAST(LEFT(xAge_Year,2) AS FLOAT)/5)*5 END AS AgeBand, COUNT(*) AS Dths
FROM BirthsDeaths.dbo.vDeathsALL d
LEFT JOIN LookupsShared.dbo.vLKP_RGN09 l
ON d.GOR_Resi = l.RGN09CDO
WHERE RGN09CD IN ('E12000001','E12000002','E12000003')
AND xYEAR in ('2014','2015','2016')
GROUP BY xYEAR, RGN09CD, RGN09NM, Sex,
CASE WHEN xAge_Year>=90 THEN 90 ELSE FLOOR(CAST(LEFT(xAge_Year,2) AS FLOAT)/5)*5 END
ORDER BY xYear, RGN09CD, Sex, AgeBand")
library(RODBC)
pops <- sqlQuery(dbhandle,"SELECT Period, OfficialCode, GeoName, Sex, SexDesc, QuinaryAgeBandMin, Population
FROM [z_Populations_DEV].[dbo].[vRes_RGN09_FiveYear]
WHERE OfficialCode in ('E12000001','E12000002','E12000003')
AND Period in ('2014','2015','2016')
ORDER BY Period, OfficialCode, Sex, QuinaryAgeBandMin")
dbhandle1 <- odbcDriverConnect('driver={SQL Server};server=SQLClusColLake\\Lake;database=z_Populations_DEV;Encrypt=true;trusted_connection=true')
dbhandle2 <- odbcDriverConnect('driver={SQL Server};server=SQLClusColLake\\Lake;database=BirthsDeaths;Encrypt=true;trusted_connection=true')
pops <- sqlQuery(dbhandle1,"SELECT Period, OfficialCode, GeoName, Sex, SexDesc, QuinaryAgeBandMin, Population
FROM [z_Populations_DEV].[dbo].[vRes_RGN09_FiveYear]
WHERE OfficialCode in ('E12000001','E12000002','E12000003')
AND Period in ('2014','2015','2016')
ORDER BY Period, OfficialCode, Sex, QuinaryAgeBandMin")
deaths <- sqlQuery(dbhandle2,"SELECT xYEAR, RGN09CD, RGN09NM, Sex,
CASE WHEN xAge_Year>=90 THEN 90 ELSE FLOOR(CAST(LEFT(xAge_Year,2) AS FLOAT)/5)*5 END AS AgeBand, COUNT(*) AS Dths
FROM BirthsDeaths.dbo.vDeathsALL d
LEFT JOIN LookupsShared.dbo.vLKP_RGN09 l
ON d.GOR_Resi = l.RGN09CDO
WHERE RGN09CD IN ('E12000001','E12000002','E12000003')
AND xYEAR in ('2014','2015','2016')
GROUP BY xYEAR, RGN09CD, RGN09NM, Sex,
CASE WHEN xAge_Year>=90 THEN 90 ELSE FLOOR(CAST(LEFT(xAge_Year,2) AS FLOAT)/5)*5 END
ORDER BY xYear, RGN09CD, Sex, AgeBand")
View(pops)
pops <- sqlQuery(dbhandle1,"SELECT Period, OfficialCode, GeoName, Sex, SexDesc, QuinaryAgeBandMin, Population
FROM [z_Populations_DEV].[dbo].[vRes_RGN09_FiveYear]
WHERE OfficialCode in ('E12000001','E12000002','E12000003')
AND Period in ('2014','2015','2016')
AND Sex in (1,2)
ORDER BY Period, OfficialCode, Sex, QuinaryAgeBandMin")
nrows(pops)
library(dplyr)
nrows(pops)
nrow(pops)
nroew(deaths)
nrow(deaths)
nrow(pops) == 342
View(pops)
View(deaths)
pops[1:4,6]
select(pops,Period, OfficialCode, Sex, QuinaryAgeBandMin)
select(pops,Period, OfficialCode, Sex, QuinaryAgeBandMin) = select(deaths(xYear, RGN09CD, Sex, AgeBand)
select(pops,Period, OfficialCode, Sex, QuinaryAgeBandMin) == select(deaths(xYear, RGN09CD, Sex, AgeBand)
select(pops,Period, OfficialCode, Sex, QuinaryAgeBandMin) == select(deaths(xYear, RGN09CD, Sex, AgeBand)
select(pops,Period, OfficialCode, Sex, QuinaryAgeBandMin) == select(deaths,xYear, RGN09CD, Sex, AgeBand)
View(deaths)
select(pops,Period, OfficialCode, Sex, QuinaryAgeBandMin) == select(deaths,xYEAR, RGN09CD, Sex, AgeBand)
identical(select(pops,Period, OfficialCode, Sex, QuinaryAgeBandMin),select(deaths,xYEAR, RGN09CD, Sex, AgeBand))
View(deaths)
View(pops)
str(deaths)
str(pops)
library(testthat)
expect_equal(select(pops,Period, OfficialCode, Sex, QuinaryAgeBandMin),
select(deaths,xYEAR, RGN09CD, Sex, AgeBand), check.attributes=FALSE, check.names=FALSE)
?expect_equal
expect_identical(select(pops,Period, OfficialCode, Sex, QuinaryAgeBandMin),
select(deaths,xYEAR, RGN09CD, Sex, AgeBand), check.attributes=FALSE, check.names=FALSE)
?all.equal
all.equal(select(pops,Period, OfficialCode, Sex, QuinaryAgeBandMin),
select(deaths,xYEAR, RGN09CD, Sex, AgeBand), check.attributes=FALSE, check.names=FALSE)
nrow(pops) == 342
nrow(deaths) == 342
all.equal(select(pops,Period, OfficialCode, Sex, QuinaryAgeBandMin),
select(deaths,xYEAR, RGN09CD, Sex, AgeBand), check.attributes=FALSE, check.names=FALSE)
library(PHEstatmethods)
esp2013
View(pops)
all.equal(esp2013*6,c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,95,90))
View(pops)
c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,95,90)*6
all.equal(select(pops,6),rep(c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,95,90),times=6))
all.equal(select(pops,6),rep(c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,95,90),times=18))
all.equal(select(pops,6),
rep(c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,95,90),times=18),
check.attributes=FALSE, check.names=FALSE)
select(pops,6)
rep(c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,95,90),times=18
)
all.equal(select(pops,6),
rep(c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90),times=18),
check.attributes=FALSE, check.names=FALSE)
select(pops,6)
as.vector(rep(c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90),times=18))
as.vector(select(pops,6))
test <- as.vector(select(pops,6))
?as.matrix
test <- as.matrix(select(pops,6))
test
as.matrix(rep(c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90),times=18))
all.equal(as.vector(select(pops,6)),
as.matrix(rep(c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90),times=18)),
check.attributes=FALSE, check.names=FALSE)
as.matrix(rep(c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90),times=18),byrow=TRUE)
all.equal(select(pops,6),
rep(c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90),times=18),
check.attributes=FALSE, check.names=FALSE)
all.equal(select(pops,6),
data.frame(rep(c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90),times=18)),
check.attributes=FALSE, check.names=FALSE)
View(pops)
pops_NW_2016 <- filter(pops,Period == 2016, GeoName == "North West")
View(pops_NW_2016)
pops_NW_2016   <- filter(pops,Period == 2016, GeoName == "North West", Sex == 1)
deaths_NW_2016 <- filter(deaths, xYEAR == 2016, RGN09NM == "North West", Sex == 1)
View(pops_NW_2016)
View(deaths_NW_2016)
phe_dsr(deaths_NW_2016$dths, pops_NW_2016$Population,esp2013)
str(deaths_NW_2016$dths)
str(deaths_NW_2016)
str(pops_NW_2016)
deaths_NW_2016$dths
View(deaths_NW_2016)
phe_dsr(deaths_NW_2016$Dths, pops_NW_2016$Population,esp2013)
str(pops)
str(esp2013)
View(pops)
?merge
?full_join
dbhandle1 <- odbcDriverConnect('driver={SQL Server};server=SQLClusColLake\\Lake;database=z_Populations_DEV;Encrypt=true;trusted_connection=true')
dbhandle2 <- odbcDriverConnect('driver={SQL Server};server=SQLClusColLake\\Lake;database=BirthsDeaths;Encrypt=true;trusted_connection=true')
pops <- sqlQuery(dbhandle1,"SELECT Period, OfficialCode as RGN09CD, GeoName as RGN09NM,
Sex, SexDesc, QuinaryAgeBandMin as AgeBand, Population
FROM [z_Populations_DEV].[dbo].[vRes_RGN09_FiveYear]
WHERE OfficialCode in ('E12000001','E12000002','E12000003')
AND Period in ('2014','2015','2016')
AND Sex in (1,2)
ORDER BY Period, OfficialCode, Sex, QuinaryAgeBandMin")
deaths <- sqlQuery(dbhandle2,"SELECT xYEAR as Period, RGN09CD, RGN09NM, Sex,
CASE WHEN xAge_Year>=90 THEN 90 ELSE FLOOR(CAST(LEFT(xAge_Year,2) AS FLOAT)/5)*5 END AS AgeBand, COUNT(*) AS Dths
FROM BirthsDeaths.dbo.vDeathsALL d
LEFT JOIN LookupsShared.dbo.vLKP_RGN09 l
ON d.GOR_Resi = l.RGN09CDO
WHERE RGN09CD IN ('E12000001','E12000002','E12000003')
AND xYEAR in ('2014','2015','2016')
GROUP BY xYEAR, RGN09CD, RGN09NM, Sex,
CASE WHEN xAge_Year>=90 THEN 90 ELSE FLOOR(CAST(LEFT(xAge_Year,2) AS FLOAT)/5)*5 END
ORDER BY xYear, RGN09CD, Sex, AgeBand")
odbcClose(dbhandle1)
odbcClose(dbhandle2)
df <- full_join(pops,deaths, by = c("Period","RGN09CD","Sex"))
View(df)
View(deaths)
df <- full_join(pops,deaths, by = c("Period","RGN09CD","Sex","AgeBand"))
View(df)
df <- full_join(pops,deaths, by = c("Period","RGN09CD","RGN09NM","Sex","AgeBand"))
View(df)
View(df)
df <- full_join(pops,deaths, by = c("Period","RGN09CD","RGN09NM","Sex","AgeBand")) %>%
mutate(group_ref = paste(Period,"_",RGN09CD,"_"Sex)) %>%
df <- full_join(pops,deaths, by = c("Period","RGN09CD","RGN09NM","Sex","AgeBand")) %>%
mutate(group_ref = paste(Period,"_",RGN09CD,"_",Sex)) %>%
select(group_ref,AgeBand, Population, Dths)
View(df)
phe_dsr(df$Dths, df$Population,esp2013)
phe_dsr(df$Dths, df$Population,esp2013, groupref = "group_ref")
phe_dsr(df$Dths, df$Population,esp2013, groupref = df$group_ref)
dbhandle1 <- odbcDriverConnect('driver={SQL Server};server=SQLClusColLake\\Lake;database=z_Populations_DEV;Encrypt=true;trusted_connection=true')
dbhandle2 <- odbcDriverConnect('driver={SQL Server};server=SQLClusColLake\\Lake;database=BirthsDeaths;Encrypt=true;trusted_connection=true')
pops <- sqlQuery(dbhandle1,"SELECT Period, OfficialCode as RGN09CD, GeoName as RGN09NM,
Sex, SexDesc, QuinaryAgeBandMin as AgeBand, Population
FROM [z_Populations_DEV].[dbo].[vRes_RGN09_FiveYear]
WHERE OfficialCode in ('E12000001','E12000002','E12000003')
AND Period in ('2014','2015','2016')
AND Sex in (1,2)
ORDER BY Period, OfficialCode, Sex, QuinaryAgeBandMin")
deaths <- sqlQuery(dbhandle2,"SELECT xYEAR as Period, RGN09CD, RGN09NM, Sex,
CASE WHEN xAge_Year>=90 THEN 90 ELSE FLOOR(CAST(LEFT(xAge_Year,2) AS FLOAT)/5)*5 END AS AgeBand, COUNT(*) AS Dths
FROM BirthsDeaths.dbo.vDeathsALL d
LEFT JOIN LookupsShared.dbo.vLKP_RGN09 l
ON d.GOR_Resi = l.RGN09CDO
WHERE RGN09CD IN ('E12000001','E12000002','E12000003')
AND xYEAR in ('2014','2015','2016')
GROUP BY xYEAR, RGN09CD, RGN09NM, Sex,
CASE WHEN xAge_Year>=90 THEN 90 ELSE FLOOR(CAST(LEFT(xAge_Year,2) AS FLOAT)/5)*5 END
ORDER BY xYear, RGN09CD, Sex, AgeBand")
odbcClose(dbhandle1)
odbcClose(dbhandle2)
df <- full_join(pops,deaths, by = c("Period","RGN09CD","RGN09NM","Sex","AgeBand")) %>%
mutate(group_ref = paste(Period,"_",RGN09CD,"_",Sex)) %>%
select(group_ref,AgeBand, Population, Dths)
phe_dsr(df$Dths, df$Population,esp2013, groupref = "group_ref")
