if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
#good code
phe_dsr(test_DSR_multiarea,count,pop,stdpop=esp2013)
phe_dsr(test_DSR_1976,count,pop,stdpop=esp2013[1:18])
phe_dsr(test_DSR_1976,count,pop,stdpop=test_DSR_1976$stdpop)
phe_dsr(test_DSR_1976,count,pop,stdpop)
phe_dsr(test,count,pop,esp1976)
#OR:
test <- test_DSR_1976 %>%
+ mutate(esp1976 = stdpop) %>%
+ select(-stdpop)
test <- test_DSR_1976
View(test)
#OR:
test <- test_DSR_1976 %>%
mutate(esp1976 = stdpop) %>%
select(-stdpop)
phe_dsr(test,count,pop,esp1976)
View(test)
str(test)
str(test_DSR_1976)
View(test)
#bad code
phe_dsr(test_DSR_multiarea,count,pop,esp2013[18])
#bad code
phe_dsr(test_DSR_multiarea,count,pop,esp2013[18]) # bad, stdpop is vector - stdpop length must equal number of rows in each group within data
phe_dsr(test_DSR_multiarea,count,pop,test_DSR_1976$stdpop) # bad, stdpop is vector, stdpop length must equal number of rows in each group within data
phe_dsr(slice(test_DSR_multiarea,54),count,pop,esp2013) # bad, stdpop is column from data, data must contain the same number of rows for each group
#good code
phe_dsr(test_DSR_multiarea,count,pop,stdpop=esp2013) # good, stdpop is vector
phe_dsr(test_DSR_1976,count,pop,stdpop=esp2013[1:18]) # good, stdpop is vector
phe_dsr(test_DSR_1976,count,pop,stdpop=test_DSR_1976$stdpop) # good, stdpop is vector
phe_dsr(test_DSR_1976,count,pop,stdpop) # good, stdpop is column reference
#bad code
phe_dsr(test_DSR_multiarea,count,pop,esp2013[18]) # bad, stdpop is vector - stdpop length must equal number of rows in each group within data
phe_dsr(test_DSR_multiarea,count,pop,test_DSR_1976$stdpop) # bad, stdpop is vector, stdpop length must equal number of rows in each group within data
phe_dsr(slice(test_DSR_multiarea,54),count,pop,esp2013) # bad, stdpop is column from data, data must contain the same number of rows for each group
rm(list=ls())
#good code
phe_dsr(test_DSR_multiarea,count,pop,stdpop=esp2013) # good, stdpop is vector
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "combined", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
} else if (n_distinct(select(summarise(data,n=n()),n)) != 1) {
stop("data must contain the same number of rows for each group")
} else if (!exists("stdpop", where=data)) {
if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%"),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$confidence[phe_dsr$total_count < 10] <- "NA - total count is < 10"
phe_dsr$method[phe_dsr$total_count < 10]     <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
# -------------------------------------------------------------------------------------------------
#' Calculates lower confidence limit for an observed number of events using Byar's method.
#'
#' @param x the observed number of events; numeric vector; no default
#' @param confidence the required level of confidence expressed as a number between 0.9 and 1
#'                   or 90 and 100; numeric; default 0.95
#'
#' @return Returns a lower confidence limit for an observed number of events using Byar's method
#'
#' @examples
#' byars_lower(65)
#' byars_lower(65,99.8)
#'
#' @export
#'
#' @family phe statistical functions
#' @seealso \code{\link{phe_proportion}} for proportions,
#'          \code{\link{phe_rate}} for rates,
#'          \code{\link{phe_mean}} for means,
#'          \code{\link{phe_dsr}} for directly standardised rates,
#'          \code{\link{phe_isr}} for indirectly standardised ratios/rates and standardised mortality ratios
# -------------------------------------------------------------------------------------------------
# create function to calculate Byar's lower CI limit
byars_lower <- function(x, confidence = 0.95) {
# validate arguments
if (any(x < 0)) {
stop("observed events must all be greater than or equal to zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# populate z
z <- qnorm(confidence + (1-confidence)/2)
# calculate
byars_lower <- x*(1-1/(9*x)-z/(3*sqrt(x)))^3
return(byars_lower)
}
# -------------------------------------------------------------------------------------------------
#' Calculates upper confidence limit for an observed number of events using Byar's method.
#'
#' @param x the observed number of events; numeric vector; no default
#' @param confidence the level of confidence required expressed as a number between 0.9 and 1
#'                   or 90 and 100; numeric; default 0.95
#'
#' @return Returns an upper confidence limit for an observed number of events using Byar's method
#'
#' @examples
#' byars_upper(65)
#' byars_upper(65,99.8)
#'
#' @export
#'
#' @family phe statistical functions
#' @seealso \code{\link{phe_proportion}} for proportions,
#'          \code{\link{phe_rate}} for rates,
#'          \code{\link{phe_mean}} for means,
#'          \code{\link{phe_dsr}} for directly standardised rates,
#'          \code{\link{phe_isr}} for indirectly standardised ratios/rates and standardised mortality ratios
# -------------------------------------------------------------------------------------------------
# create function to calculate Byar's upper CI limit
byars_upper <- function(x, confidence = 0.95) {
# validate arguments
if (any(x < 0)) {
stop("observed events (x) must all be greater than or equal to zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# populate z
z <- qnorm(confidence + (1-confidence)/2)
byars_upper <- (x+1)*(1-1/(9*(x+1))+z/(3*sqrt(x+1)))^3
return(byars_upper)
}
#good code
phe_dsr(test_DSR_multiarea,count,pop,stdpop=esp2013) # good, stdpop is vector
test_DSR_multiarea <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_multiarea", col_names=TRUE) %>%
group_by(area)
test_DSR_1976      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_1976",      col_names=TRUE)
test_DSR_err1      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_err1",      col_names=TRUE)
test_DSR_err2      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_err2",      col_names=TRUE)
test_DSR_err3      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_err3",      col_names=TRUE)
test_DSR_results   <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",        col_names=TRUE)
#good code
phe_dsr(test_DSR_multiarea,count,pop,stdpop=esp2013) # good, stdpop is vector
# esp2013
esp2013 <- c(5000,5500,5500,5500,6000,6000,6500,7000,7000,7000,7000,6500,6000,5500,5000,4000,2500,1500,1000)
# Proportions
test_Prop_1   <- read_excel(".\\tests\\testthat\\testdata_Proportion.xlsx", sheet="testdata_Prop_1",   col_names=TRUE)
test_Prop_100 <- read_excel(".\\tests\\testthat\\testdata_Proportion.xlsx", sheet="testdata_Prop_100", col_names=TRUE)
test_Prop_1$Area   <- as.factor(test_Prop_1$Area)
test_Prop_100$Area <- as.factor(test_Prop_100$Area)
#Rates
test_Rate_100000 <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx", sheet="testdata_Rate_100000", col_names=TRUE)
test_Rate_100    <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx", sheet="testdata_Rate_100",    col_names=TRUE)
#test_Rate_100$Area      <- as.factor(test_Rate_100$Area)
#test_Rate_100000$Area   <- as.factor(test_Rate_100000$Area)
#Means
test_Mean         <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean",         col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean_results", col_names=TRUE)
test_Mean$area         <- as.factor(test_Mean$area)
test_Mean_results$area <- as.factor(test_Mean_results$area)
# DSRs
test_DSR_multiarea <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_multiarea", col_names=TRUE) %>%
group_by(area)
test_DSR_1976      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_1976",      col_names=TRUE)
test_DSR_err1      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_err1",      col_names=TRUE)
test_DSR_err2      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_err2",      col_names=TRUE)
test_DSR_err3      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_err3",      col_names=TRUE)
test_DSR_results   <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",        col_names=TRUE)
# ISRs
test_ISR_multiarea <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testdata_multiarea", col_names=TRUE)
test_ISR_err1      <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testdata_err1",      col_names=TRUE)
test_ISR_err2      <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testdata_err2",      col_names=TRUE)
test_ISR_err3      <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testdata_err3",      col_names=TRUE)
test_ISR_results   <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testresults",        col_names=TRUE)
test_ISR_refdata   <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="refdata",            col_names=TRUE)
test_ISR_results$group <- as.factor(test_ISR_results$group)
devtools::use_data(test_Prop_1, test_Prop_100,
test_Rate_100, test_Rate_100000,
test_Mean, test_Mean_results,
test_DSR_multiarea, test_DSR_1976, test_DSR_err1, test_DSR_err2, test_DSR_err3, test_DSR_results,
test_ISR_multiarea, test_ISR_refdata, test_ISR_err1, test_ISR_err2, test_ISR_err3, test_ISR_results,
internal = TRUE, overwrite = TRUE)
devtools::document()
#good code
phe_dsr(test_DSR_multiarea,count,pop,stdpop=esp2013) # good, stdpop is vector
phe_dsr(test_DSR_1976,count,pop,stdpop=esp2013[1:18]) # good, stdpop is vector
phe_dsr(test_DSR_1976,count,pop,stdpop=test_DSR_1976$stdpop) # good, stdpop is vector
phe_dsr(test_DSR_1976,count,pop,stdpop) # good, stdpop is column reference
#bad code
phe_dsr(test_DSR_multiarea,count,pop,esp2013[18]) # bad, stdpop is vector - stdpop length must equal number of rows in each group within data
phe_dsr(test_DSR_multiarea,count,pop,test_DSR_1976$stdpop) # bad, stdpop is vector, stdpop length must equal number of rows in each group within data
phe_dsr(slice(test_DSR_multiarea,54),count,pop,esp2013) # bad, stdpop is column from data, data must contain the same number of rows for each group
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "combined", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
} else if (n_distinct(select(summarise(data,n=n()),n)) != 1) {
stop("data must contain the same number of rows for each group")
#  } else if (!exists("stdpop", where=data)) {
#      if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
#        stop("stdpop length must equal number of rows in each group within data")
#    }
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%"),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$confidence[phe_dsr$total_count < 10] <- "NA - total count is < 10"
phe_dsr$method[phe_dsr$total_count < 10]     <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
rm(list=ls())
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "combined", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
} else if (n_distinct(select(summarise(data,n=n()),n)) != 1) {
stop("data must contain the same number of rows for each group")
#  } else if (!exists("stdpop", where=data)) {
#      if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
#        stop("stdpop length must equal number of rows in each group within data")
#    }
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%"),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$confidence[phe_dsr$total_count < 10] <- "NA - total count is < 10"
phe_dsr$method[phe_dsr$total_count < 10]     <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
library(dplyr)
library(rlang)
esp2013 <- c(5000,5500,5500,5500,6000,6000,6500,7000,7000,7000,7000,6500,6000,5500,5000,4000,2500,1500,1000)
# Proportions
test_Prop_1   <- read_excel(".\\tests\\testthat\\testdata_Proportion.xlsx", sheet="testdata_Prop_1",   col_names=TRUE)
test_Prop_100 <- read_excel(".\\tests\\testthat\\testdata_Proportion.xlsx", sheet="testdata_Prop_100", col_names=TRUE)
test_Prop_1$Area   <- as.factor(test_Prop_1$Area)
test_Prop_100$Area <- as.factor(test_Prop_100$Area)
#Rates
test_Rate_100000 <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx", sheet="testdata_Rate_100000", col_names=TRUE)
test_Rate_100    <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx", sheet="testdata_Rate_100",    col_names=TRUE)
#test_Rate_100$Area      <- as.factor(test_Rate_100$Area)
#test_Rate_100000$Area   <- as.factor(test_Rate_100000$Area)
#Means
test_Mean         <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean",         col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean_results", col_names=TRUE)
test_Mean$area         <- as.factor(test_Mean$area)
test_Mean_results$area <- as.factor(test_Mean_results$area)
# DSRs
test_DSR_multiarea <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_multiarea", col_names=TRUE) %>%
group_by(area)
test_DSR_1976      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_1976",      col_names=TRUE)
test_DSR_err1      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_err1",      col_names=TRUE)
test_DSR_err2      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_err2",      col_names=TRUE)
test_DSR_err3      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_err3",      col_names=TRUE)
test_DSR_results   <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",        col_names=TRUE)
# ISRs
test_ISR_multiarea <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testdata_multiarea", col_names=TRUE)
test_ISR_err1      <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testdata_err1",      col_names=TRUE)
test_ISR_err2      <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testdata_err2",      col_names=TRUE)
test_ISR_err3      <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testdata_err3",      col_names=TRUE)
test_ISR_results   <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testresults",        col_names=TRUE)
test_ISR_refdata   <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="refdata",            col_names=TRUE)
test_ISR_results$group <- as.factor(test_ISR_results$group)
library(readxl)
esp2013 <- c(5000,5500,5500,5500,6000,6000,6500,7000,7000,7000,7000,6500,6000,5500,5000,4000,2500,1500,1000)
# Proportions
test_Prop_1   <- read_excel(".\\tests\\testthat\\testdata_Proportion.xlsx", sheet="testdata_Prop_1",   col_names=TRUE)
test_Prop_100 <- read_excel(".\\tests\\testthat\\testdata_Proportion.xlsx", sheet="testdata_Prop_100", col_names=TRUE)
test_Prop_1$Area   <- as.factor(test_Prop_1$Area)
test_Prop_100$Area <- as.factor(test_Prop_100$Area)
#Rates
test_Rate_100000 <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx", sheet="testdata_Rate_100000", col_names=TRUE)
test_Rate_100    <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx", sheet="testdata_Rate_100",    col_names=TRUE)
#test_Rate_100$Area      <- as.factor(test_Rate_100$Area)
#test_Rate_100000$Area   <- as.factor(test_Rate_100000$Area)
#Means
test_Mean         <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean",         col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean_results", col_names=TRUE)
test_Mean$area         <- as.factor(test_Mean$area)
test_Mean_results$area <- as.factor(test_Mean_results$area)
# DSRs
test_DSR_multiarea <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_multiarea", col_names=TRUE) %>%
group_by(area)
test_DSR_1976      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_1976",      col_names=TRUE)
test_DSR_err1      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_err1",      col_names=TRUE)
test_DSR_err2      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_err2",      col_names=TRUE)
test_DSR_err3      <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_err3",      col_names=TRUE)
test_DSR_results   <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",        col_names=TRUE)
# ISRs
test_ISR_multiarea <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testdata_multiarea", col_names=TRUE)
test_ISR_err1      <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testdata_err1",      col_names=TRUE)
test_ISR_err2      <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testdata_err2",      col_names=TRUE)
test_ISR_err3      <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testdata_err3",      col_names=TRUE)
test_ISR_results   <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="testresults",        col_names=TRUE)
test_ISR_refdata   <- read_excel(".\\tests\\testthat\\testdata_ISR.xlsx", sheet="refdata",            col_names=TRUE)
test_ISR_results$group <- as.factor(test_ISR_results$group)
phe_dsr(test_DSR_multiarea, count, pop, esp2013)
# create function to calculate Byar's lower CI limit
byars_lower <- function(x, confidence = 0.95) {
# validate arguments
if (any(x < 0)) {
stop("observed events must all be greater than or equal to zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# populate z
z <- qnorm(confidence + (1-confidence)/2)
# calculate
byars_lower <- x*(1-1/(9*x)-z/(3*sqrt(x)))^3
return(byars_lower)
}
# -------------------------------------------------------------------------------------------------
#' Calculates upper confidence limit for an observed number of events using Byar's method.
#'
#' @param x the observed number of events; numeric vector; no default
#' @param confidence the level of confidence required expressed as a number between 0.9 and 1
#'                   or 90 and 100; numeric; default 0.95
#'
#' @return Returns an upper confidence limit for an observed number of events using Byar's method
#'
#' @examples
#' byars_upper(65)
#' byars_upper(65,99.8)
#'
#' @export
#'
#' @family phe statistical functions
#' @seealso \code{\link{phe_proportion}} for proportions,
#'          \code{\link{phe_rate}} for rates,
#'          \code{\link{phe_mean}} for means,
#'          \code{\link{phe_dsr}} for directly standardised rates,
#'          \code{\link{phe_isr}} for indirectly standardised ratios/rates and standardised mortality ratios
# -------------------------------------------------------------------------------------------------
# create function to calculate Byar's upper CI limit
byars_upper <- function(x, confidence = 0.95) {
# validate arguments
if (any(x < 0)) {
stop("observed events (x) must all be greater than or equal to zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# populate z
z <- qnorm(confidence + (1-confidence)/2)
byars_upper <- (x+1)*(1-1/(9*(x+1))+z/(3*sqrt(x+1)))^3
return(byars_upper)
}
phe_dsr(test_DSR_multiarea, count, pop, esp2013)
library(testthat)
View(test_DSR_multiarea)
phe_dsr(test_DSR_1976, count, pop, type="full", stdpop = test_DSR_1976$stdpop, multiplier=10000)
