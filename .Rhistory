?phe_mean
?phe_isr
?phe_smr
?wilson_lower
?wilson_upper
?byars_lower
?byars_upper
devtools::document()
phe_dsr(testdata_multiarea, count, pop, esp2013)
phe_dsr(test_multiarea, count, pop, esp2013)
esp <- as.factor(esp2013)
str(esp)
head(esp)
phe_dsr(test_multiarea, count, pop, esp)
phe_dsr(test_DSR_multiarea, count, pop, esp2013)
phe_rate(test_Rate_100_input,Numerator,Denominator)
test_multiarea
phe_dsr(test_multiarea, count, pop, esp2013)
phe_dsr(test_DSR_1976, count, pop, type="full", stdpop = test_DSR_1976$stdpop, multiplier=10000)
phe_dsr(test_multiarea, count, pop, type="full", stdpop = esp2013, multiplier=1000, conf.level = 99.8)
phe_dsr(test_multiarea, count, pop, type="full", stdpop = esp2013, multiplier=1000, confidence = 99.8)
Y2015 <- test_multiarea %>%
mutate(Yr=2015)
Y2016 <- test_multiarea %>%
mutate(Yr=2016,
count = count + 10)
MultiGroups <- bind_rows(Y2015,Y2016)
phe_dsr(MultiGroups, count, pop, esp2013)
View(MultiGroups)
phe_dsr(MultiGroups, count, pop, esp2013)
phe_dsr(MultiGroups, count, pop, rep(esp2013,6))
phe_dsr(MultiGroups, count, pop, rep(esp2013,3))
phe_dsr(MultiGroups, count, pop, rep(esp2013,2))
MultiGroups2 <- MultiGroups %>%
group_by(area, Yr)
phe_dsr(MultiGroups2, count, pop, esp2013, type="full")
MultiGroups2
View(MultiGroups2)
debug(phe_dsr)
phe_dsr(MultiGroups2, count, pop, esp2013, type="full")
n_distinct(select(summarise(data, n = n()), n))
summarise(data, n = n())
select(summarise(data, n = n()), n)
n_distinct(summarise(data, n = n()))
n_distinct(ungroup(summarise(data, n = n())))
ungroup(summarise(data, n = n()))
select(ungroup(summarise(data, n = n())),n)
n_distinct(select(ungroup(summarise(data, n = n())),n))
# define the DSR function using Dobson method
phe_dsr <- function(data, x, n, stdpop, type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(ungroup(summarise(data,n=n())),n)) != 1) {
stop("data must contain the same number of rows for each group")
} else if(pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
#  } else if (!exists("stdpop", where=data)) {
#      if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
#        stop("stdpop length must equal number of rows in each group within data")
#    }
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
value = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = value + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = value + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%",sep=""),
statistic = paste("dsr per",format(multiplier,scientific=F)),
method = "Dobson")
phe_dsr$value[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
phe_dsr(MultiGroups2, count, pop, esp2013, type="full")
expect_error(phe_dsr(filter(test_multiarea,count < 100), count, pop, stdpop = esp2013),
"data must contain the same number of rows for each group",info="error num rows per group")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = test_DSR_1976$stdpop),
"stdpop length must equal number of rows in each group within data",info="error stdpop length")
phe_dsr(MultiGroups2, count, pop, esp2013, type="full")
test_multigroup  <- read_excel(".\\tests\\testthat\\testdata_DSR_ISR_SMR.xlsx", sheet="test_multigroup", col_names=TRUE) %>%
group_by(area,year)
test_multigroup  <- read_excel(".\\tests\\testthat\\testdata_DSR_ISR_SMR.xlsx", sheet="testdata_multigroup", col_names=TRUE) %>%
group_by(area,year)
# use this code to save loaded data to sysdata folder:
devtools::use_data(test_Prop,
test_Rate,
test_Mean, test_Mean_Grp, test_Mean_results,
test_multiarea, test_multigroup, test_DSR_1976, test_err1, test_err2, test_err3, test_DSR_results,
test_ISR_refdata, test_ISR_results, test_ISR_ownref,
internal = TRUE, overwrite = TRUE)
phe_dsr(test_multigroup,count,pop,esp2013)
debug(phe_dsr)
phe_dsr(test_multigroup,count,pop,esp2013)
str(data)
select(summarise(data, n = n()), n)
slice(select(summarise(data, n = n()), n), 1)
slice(select(ungroup(summarise(data, n = n())), n), 1)
# define the DSR function using Dobson method
phe_dsr <- function(data, x, n, stdpop, type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(ungroup(summarise(data,n=n())),n)) != 1) {
stop("data must contain the same number of rows for each group")
} else if(pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
#  } else if (!exists("stdpop", where=data)) {
#      if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
#        stop("stdpop length must equal number of rows in each group within data")
#    }
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
value = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = value + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = value + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%",sep=""),
statistic = paste("dsr per",format(multiplier,scientific=F)),
method = "Dobson")
phe_dsr$value[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
phe_dsr(MultiGroups2, count, pop, esp2013, type="full")
phe_dsr(test_multigroup,count,pop,esp2013)
expect_error(phe_dsr(filter(test_multiarea,count < 100), count, pop, stdpop = esp2013),
"data must contain the same number of rows for each group",info="error num rows per group")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = test_DSR_1976$stdpop),
"stdpop length must equal number of rows in each group within data",info="error stdpop length")
phe_isr(test_multigroup,count,pop,test_ISR_refdata$refcount,test_ISR_refdata$refpop)
phe_isr <- function(data, x, n, x_ref, n_ref, type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(x_ref)|missing(n_ref)) {
stop("function phe_isr requires at least 5 arguments: data, x, n, x_ref and n_ref")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquox_ref <- enquo(x_ref)
enquon_ref <- enquo(n_ref)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(summarise(data,n=n()),n)) != 1) {
stop("data must contain the same number of rows for each group")
}  else if (pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(x_ref)) {
stop("x_ref length must equal number of rows in each group within data")
}  else if (pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(n_ref)) {
stop("n_ref length must equal number of rows in each group within data")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
phe_isr <- data %>%
mutate(exp_x = (!!x_ref)/(!!n_ref) * (!!n)) %>%
summarise(observed  = sum((!!x)),
expected  = sum(exp_x),
ref_rate = sum((!!x_ref)) / sum((!!n_ref)) * multiplier) %>%
mutate(value     = observed / expected * ref_rate,
lowercl = if_else(observed<10, qchisq((1-confidence)/2,2*observed)/2/expected * ref_rate,
byars_lower(observed,confidence)/expected * ref_rate),
uppercl = if_else(observed<10, qchisq(confidence+(1-confidence)/2,2*observed+2)/2/expected * ref_rate,
byars_upper(observed,confidence)/expected * ref_rate),
confidence = paste(confidence*100,"%"),
statistic = paste("isr per",format(multiplier,scientific=F)),
method  = if_else(observed<10,"Exact","Byars"))
if (type == "lower") {
phe_isr <- phe_isr %>%
select(-observed, -expected, -ref_rate, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_isr <- phe_isr %>%
select(-observed, -expected, -ref_rate, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_isr <- phe_isr %>%
select(-observed, -expected, -ref_rate, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_isr <- phe_isr %>%
select(-observed, -expected, -ref_rate, -confidence, -statistic, -method)
}
return(phe_isr)
}
phe_isr(test_multigroup,count,pop,test_ISR_refdata$refcount,test_ISR_refdata$refpop)
debug(phe_isr)
phe_isr(test_multigroup,count,pop,test_ISR_refdata$refcount,test_ISR_refdata$refpop)
phe_isr <- function(data, x, n, x_ref, n_ref, type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(x_ref)|missing(n_ref)) {
stop("function phe_isr requires at least 5 arguments: data, x, n, x_ref and n_ref")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquox_ref <- enquo(x_ref)
enquon_ref <- enquo(n_ref)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(ungroup(summarise(data,n=n())),n)) != 1) {
stop("data must contain the same number of rows for each group")
}  else if (pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(x_ref)) {
stop("x_ref length must equal number of rows in each group within data")
}  else if (pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(n_ref)) {
stop("n_ref length must equal number of rows in each group within data")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
phe_isr <- data %>%
mutate(exp_x = (!!x_ref)/(!!n_ref) * (!!n)) %>%
summarise(observed  = sum((!!x)),
expected  = sum(exp_x),
ref_rate = sum((!!x_ref)) / sum((!!n_ref)) * multiplier) %>%
mutate(value     = observed / expected * ref_rate,
lowercl = if_else(observed<10, qchisq((1-confidence)/2,2*observed)/2/expected * ref_rate,
byars_lower(observed,confidence)/expected * ref_rate),
uppercl = if_else(observed<10, qchisq(confidence+(1-confidence)/2,2*observed+2)/2/expected * ref_rate,
byars_upper(observed,confidence)/expected * ref_rate),
confidence = paste(confidence*100,"%"),
statistic = paste("isr per",format(multiplier,scientific=F)),
method  = if_else(observed<10,"Exact","Byars"))
if (type == "lower") {
phe_isr <- phe_isr %>%
select(-observed, -expected, -ref_rate, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_isr <- phe_isr %>%
select(-observed, -expected, -ref_rate, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_isr <- phe_isr %>%
select(-observed, -expected, -ref_rate, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_isr <- phe_isr %>%
select(-observed, -expected, -ref_rate, -confidence, -statistic, -method)
}
return(phe_isr)
}
phe_isr(test_multigroup,count,pop,test_ISR_refdata$refcount,test_ISR_refdata$refpop)
phe_smr <- function(data, x, n, x_ref, n_ref, type = "standard", confidence = 0.95, ref = 1) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(x_ref)|missing(n_ref)) {
stop("function phe_smr requires at least 5 arguments: data, x, n, x_ref and n_ref")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquox_ref <- enquo(x_ref)
enquon_ref <- enquo(n_ref)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(ungroup(summarise(data,n=n())),n)) != 1) {
stop("data must contain the same number of rows for each group")
}  else if (pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(x_ref)) {
stop("x_ref length must equal number of rows in each group within data")
}  else if (pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(n_ref)) {
stop("n_ref length must equal number of rows in each group within data")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
phe_smr <- data %>%
mutate(exp_x = (!!x_ref)/(!!n_ref) * (!!n)) %>%
summarise(observed  = sum((!!x)),
expected  = sum(exp_x)) %>%
mutate(value     = observed / expected * ref,
lowercl = if_else(observed<10, qchisq((1-confidence)/2,2*observed)/2/expected * ref,
byars_lower(observed,confidence)/expected * ref),
uppercl = if_else(observed<10, qchisq(confidence+(1-confidence)/2,2*observed+2)/2/expected * ref,
byars_upper(observed,confidence)/expected * ref),
confidence = paste(confidence*100,"%"),
statistic = paste("smr x ",format(ref,scientific=F)),
method  = if_else(observed<10,"Exact","Byars"))
if (type == "lower") {
phe_smr <- phe_smr %>%
select(-observed, -expected, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_smr <- phe_smr %>%
select(-observed, -expected, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_smr <- phe_smr %>%
select(-observed, -expected, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_smr <- phe_smr %>%
select(-observed, -expected, -confidence, -statistic, -method)
}
return(phe_smr)
}
phe_smr(test_multigroup,count,pop,test_ISR_refdata$refcount,test_ISR_refdata$refpop)
phe_mean(test_multigroup,count)
check <- ungroup(test_multigroup)
phe_mean(check,count)
phe_dsr(test_DSR_1976,count,pop, test_DSR_1976$stdpop)
expect_equal(phe_dsr(test_DSR_1976, count, pop, stdpop = test_DSR_1976$stdpop),
select(slice(test_DSR_results,12),4:6),
check.attributes=FALSE, check.names=FALSE,info="test default with own stdpop by vector")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013)),
select(test_DSR_results[9:11,],1,4:6),
check.attributes=FALSE, check.names=FALSE,info="test default with esp2013")
data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013))
data.frame(select(test_DSR_results[9:11,],1,4:6))
?expect_equal
format(1.5e-8,scientific=F)
dsr <- data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013))
dsr_check <- data.frame(select(test_DSR_results[9:11,],1,4:6))
dsr$value[1]
dsr_check$value[1]
dsr_check$value[1]/dsr$value[1]
as.numeric(dsr_check$value[1])/as.numeric(dsr$value[1])
# define the DSR function using Dobson method
phe_dsr <- function(data, x, n, stdpop, type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(ungroup(summarise(data,n=n())),n)) != 1) {
stop("data must contain the same number of rows for each group")
} else if(pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
#  } else if (!exists("stdpop", where=data)) {
#      if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
#        stop("stdpop length must equal number of rows in each group within data")
#    }
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
value = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = value + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = value + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%",sep=""),
statistic = paste("dsr per",format(multiplier,scientific=F)),
method = "Dobson")
#  phe_dsr$value[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
#  phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
#  phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013)),
data.frame(select(test_DSR_results[9:11,],1,4:6)),
check.attributes=FALSE, check.names=FALSE,info="test default with esp2013")
expect_equal(phe_dsr(test_multiarea, count, pop, stdpop = esp2013),
select(test_DSR_results[9:11,],1,4:6),
check.attributes=FALSE, check.names=FALSE,info="test default with esp2013")
phe_dsr(test_multiarea, count, pop, stdpop = esp2013)
select(test_DSR_results[9:11,],1,4:6)
phe_dsr(test_DSR_1976, count, pop, stdpop = test_DSR_1976$stdpop)
select(slice(test_DSR_results,12),4:6)
as.numeric(select(slice(test_DSR_results,12),4:6))
check <- data.frame(value = as.numeric(slice(test_DSR_results,12),4:6),)
check <- data.frame(value = as.numeric(slice(test_DSR_results,12),4:6))
slice(test_DSR_results,12),4:6)
slice(test_DSR_results,12)
select(slice(test_DSR_results,12),4:6)
data.frame(value = as.numerci(select(slice(test_DSR_results,12),4)),
lowercl = as.numerci(select(slice(test_DSR_results,12),5)),
uppercl = as.numerci(select(slice(test_DSR_results,12),6)))
data.frame(value = as.numeric(select(slice(test_DSR_results,12),4)),
lowercl = as.numeric(select(slice(test_DSR_results,12),5)),
uppercl = as.numeric(select(slice(test_DSR_results,12),6)))
check <- data.frame(value = as.numeric(select(slice(test_DSR_results,12),4)),
lowercl = as.numeric(select(slice(test_DSR_results,12),5)),
uppercl = as.numeric(select(slice(test_DSR_results,12),6)))
expect_equal(phe_dsr(test_DSR_1976, count, pop, stdpop = test_DSR_1976$stdpop),
check,
check.attributes=FALSE, check.names=FALSE,info="test default with own stdpop by vector")
phe_dsr(test_DSR_1976, count, pop, stdpop = test_DSR_1976$stdpop)
check
data.frame(phe_dsr(test_DSR_1976, count, pop, stdpop = test_DSR_1976$stdpop))
data.frame(check)
View(test_DSR_results)
check <- data.frame(value = as.numeric(select(slice(test_DSR_results,4),4)),
lowercl = as.numeric(select(slice(test_DSR_results,4),5)),
uppercl = as.numeric(select(slice(test_DSR_results,4),6)))
expect_equal(data.frame(phe_dsr(test_DSR_1976, count, pop, stdpop = test_DSR_1976$stdpop)),
data.frame(check),
check.attributes=FALSE, check.names=FALSE,info="test default with own stdpop by vector")
expect_equal(data.frame(phe_dsr(test_DSR_1976, count, pop, stdpop = test_DSR_1976$stdpop)),
data.frame(check),
check.attributes=FALSE, check.names=FALSE,info="test default with own stdpop by vector")
View(test_DSR_results)
