if (x < 0) {
stop("numerator must be greater than or equal to zero")
} else if (n <= 0) {
stop("denominator must be greater than zero")
} else if (x > n) {
stop("numerator must be less than or equal to denominator for a proportion statistic")
}
multiplier <- 1
if (percentage == TRUE) {
multiplier <- 100
}
lower_nm <- paste("lower",conf.level*100,"cl",sep=)
phe_proportion <- data.frame(binom.confint(x, n, conf.level, methods="wilson")) %>%
rename(proportion = mean) %>%
rename(numerator = x) %>%
rename(denominator = n) %>%
mutate(proportion = proportion * multiplier) %>%
mutate(lower = lower * multiplier) %>%
mutate(upper = upper * multiplier) %>%
rename("lower_nm" = lower)
#       if (conf.level = 0.95) {
#              rename(phe_proportion$lower95cl = phe_proportion$lower)
#        } else if (conf.level = 0.998) {
#              rename(phe_proportion$lower99.8cl = phe_proportion$lower)
#        } else {
#             rename(phe_proportion$lowercl = phe_proportion$lower)
#        }
return(phe_proportion)
}
phe_proportion(60,100,percentage=TRUE)
names(phe_proportion)
phe_proportion <- function(x, n, conf.level=0.95, percentage=FALSE) {
if (x < 0) {
stop("numerator must be greater than or equal to zero")
} else if (n <= 0) {
stop("denominator must be greater than zero")
} else if (x > n) {
stop("numerator must be less than or equal to denominator for a proportion statistic")
}
multiplier <- 1
if (percentage == TRUE) {
multiplier <- 100
}
lower_nm <- paste("lower",conf.level*100,"cl",sep=)
phe_proportion <- data.frame(binom.confint(x, n, conf.level, methods="wilson")) %>%
#     rename(proportion = mean) %>%
#      rename(numerator = x) %>%
#      rename(denominator = n) %>%
mutate(proportion = proportion * multiplier) %>%
mutate(lower = lower * multiplier) %>%
mutate(upper = upper * multiplier) %>%
rename("lower_nm" = lower)
names(phe_proportion) <- c("method","numerator","denominator","proportion",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
#       if (conf.level = 0.95) {
#              rename(phe_proportion$lower95cl = phe_proportion$lower)
#        } else if (conf.level = 0.998) {
#              rename(phe_proportion$lower99.8cl = phe_proportion$lower)
#        } else {
#             rename(phe_proportion$lowercl = phe_proportion$lower)
#        }
return(phe_proportion)
}
phe_proportion(60,100,percentage=TRUE)
phe_proportion(60,100,percentage=TRUE)
phe_proportion <- function(x, n, conf.level=0.95, percentage=FALSE) {
if (x < 0) {
stop("numerator must be greater than or equal to zero")
} else if (n <= 0) {
stop("denominator must be greater than zero")
} else if (x > n) {
stop("numerator must be less than or equal to denominator for a proportion statistic")
}
multiplier <- 1
if (percentage == TRUE) {
multiplier <- 100
}
lower_nm <- paste("lower",conf.level*100,"cl",sep=)
phe_proportion <- data.frame(binom.confint(x, n, conf.level, methods="wilson")) %>%
#     rename(proportion = mean) %>%
#      rename(numerator = x) %>%
#      rename(denominator = n) %>%
mutate(mean = mean * multiplier) %>%
mutate(lower = lower * multiplier) %>%
mutate(upper = upper * multiplier) %>%
rename("lower_nm" = lower)
names(phe_proportion) <- c("method","numerator","denominator","proportion",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
#       if (conf.level = 0.95) {
#              rename(phe_proportion$lower95cl = phe_proportion$lower)
#        } else if (conf.level = 0.998) {
#              rename(phe_proportion$lower99.8cl = phe_proportion$lower)
#        } else {
#             rename(phe_proportion$lowercl = phe_proportion$lower)
#        }
return(phe_proportion)
}
phe_proportion(60,100,percentage=TRUE)
phe_proportion <- function(x, n, conf.level=0.95, percentage=FALSE) {
if (x < 0) {
stop("numerator must be greater than or equal to zero")
} else if (n <= 0) {
stop("denominator must be greater than zero")
} else if (x > n) {
stop("numerator must be less than or equal to denominator for a proportion statistic")
}
multiplier <- 1
if (percentage == TRUE) {
multiplier <- 100
}
lower_nm <- paste("lower",conf.level*100,"cl",sep=)
phe_proportion <- data.frame(binom.confint(x, n, conf.level, methods="wilson")) %>%
#     rename(proportion = mean) %>%
#      rename(numerator = x) %>%
#      rename(denominator = n) %>%
mutate(mean = mean * multiplier) %>%
mutate(lower = lower * multiplier) %>%
mutate(upper = upper * multiplier) %>%
rename("lower_nm" = lower)
names(phe_proportion) <- c("method","numerator","denominator","proportion",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
#       if (conf.level = 0.95) {
#              rename(phe_proportion$lower95cl = phe_proportion$lower)
#        } else if (conf.level = 0.998) {
#              rename(phe_proportion$lower99.8cl = phe_proportion$lower)
#        } else {
#             rename(phe_proportion$lowercl = phe_proportion$lower)
#        }
return(phe_proportion)
}
phe_proportion(60,100,percentage=TRUE)
phe_proportion(60,100,95,percentage=TRUE)
phe_proportion(60,100,0.01,percentage=TRUE)
phe_proportion(60,100,0,percentage=TRUE)
phe_proportion(60,100,1,percentage=TRUE)
phe_proportion(60,100,1.000001,percentage=TRUE)
# create phe_proportion function to execute binom.confint with method fixed to wilson
phe_proportion <- function(x, n, conf.level=0.95, percentage=FALSE) {
if (x < 0) {
stop("numerator must be greater than or equal to zero")
} else if (n <= 0) {
stop("denominator must be greater than zero")
} else if (x > n) {
stop("numerator must be less than or equal to denominator for a proportion statistic")
} else if ((conf.int<0.9)|(conf.int >1 & conf.int <90)|(conf.int > 100)) {
stop("confidence interval must be between 90 and 99.99")
}
# scale confidence interval
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# set multiplier
multiplier <- 1
if (percentage == TRUE) {
multiplier <- 100
}
# calculate proportion and CIs
phe_proportion <- data.frame(binom.confint(x, n, conf.level, methods="wilson")) %>%
mutate(mean = mean * multiplier) %>%
mutate(lower = lower * multiplier) %>%
mutate(upper = upper * multiplier)
# set column names to be output
names(phe_proportion) <- c("method","numerator","denominator","proportion",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_proportion)
}
#Test binomial function ---------------------------------------------------------------------------
library(testthat)
library(PHEstatmethods)
# context ?? what does this line do?  do I need it?
test_that("proportion and CIs calculate correctly",{
expect_equal(phe_proportion(35078,41980),c(35078,41980,0.835588375,0.83201210,0.83910324))
expect_equal(phe_proportion(35078,41980,conf.level=0.998),c(35078,41980,0.835588375,0.82992190,0.84110220))
expect_equal(phe_proportion(65,100,conf.level=0.95),c(65,100,0.65,0.55254443,0.73635752))
expect_equal(phe_proportion(65,100,conf.level=0.998),c(65,100,0.65,0.49549466,0.77835406))
})
test_that("error generated when numerator is less than zero",{
expect_equal(phe_proportion(-65,100),"numerator must be greater than or equal to zero")
})
test_that("error generated when denominator is less than or equal to zero",{
expect_equal(phe_proportion(65,-100),"denominator must be greater than zero")
expect_equal(phe_proportion(65,0),"denominator must be greater than zero")
})
test_that("error generated when numerator is greater than denominator",{
expect_equal(phe_proportion(100,65),"numerator must be less than or equal to denominator for a proportion statistic")
})
test_that("error generated when max is not equal to 1 or 100",{
expect_equal(phe_proportion(65,100,max=1000),"function phe.binom can only output a proportion (max=1) or a percentage (max=100)")
})
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100) {
rate <- x/n*multiplier
lowercl<-x*(1-1/(9*x)-qnorm(1-0.05/2)/(3*sqrt(x)))^3
uppercl<-(x+1)*(1-1/(9*(x+1))+qnorm(1-0.05/2)/(3*sqrt(x+1)))^3
phe_rate <- c(rate, lowercl, uppercl)
return(phe_rate)
}
phe_rate(65,100,multipiplier = 100000)
phe_rate(65,100,multipilier = 100000)
phe_rate(65,100,multiplier = 100000)
phe_rate(800,10000,multiplier = 100000)
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100) {
rate <- x/n*multiplier
lowercl<-x*(1-1/(9*x)-qnorm(1-0.05/2)/(3*sqrt(x)))^3/n*multiplier
uppercl<-(x+1)*(1-1/(9*(x+1))+qnorm(1-0.05/2)/(3*sqrt(x+1)))^3/n*mltiplier
phe_rate <- c(rate, lowercl, uppercl)
return(phe_rate)
}
phe_rate(800,10000,multiplier = 100000)
#______________________________________________________________________________________________________
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100) {
rate <- x/n*multiplier
lowercl<-x*(1-1/(9*x)-qnorm(1-0.05/2)/(3*sqrt(x)))^3/n*multiplier
uppercl<-(x+1)*(1-1/(9*(x+1))+qnorm(1-0.05/2)/(3*sqrt(x+1)))^3/n*multiplier
phe_rate <- c(rate, lowercl, uppercl)
return(phe_rate)
}
byars_lower <- function(x) {
x*(1-1/(9*x)-qnorm(1-0.05/2)/(3*sqrt(x)))^3
return(byars_lower)
}
byars_upper <- function(x) {
(x+1)*(1-1/(9*(x+1))+qnorm(1-0.05/2)/(3*sqrt(x+1)))^3
return(byars_upper)
}
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100) {
rate <- x/n*multiplier
lowercl<-byars_lower(x)/n*multiplier
uppercl<-byars_upper(x)/n*multiplier
phe_rate <- c(rate, lowercl, uppercl)
return(phe_rate)
}
phe_rate(800,10000,multiplier = 100000)
byars_lower(800)
byars_lower <- function(x) {
byars_lower <- x*(1-1/(9*x)-qnorm(1-0.05/2)/(3*sqrt(x)))^3
return(byars_lower)
}
byars_upper <- function(x) {
byars_upper <- (x+1)*(1-1/(9*(x+1))+qnorm(1-0.05/2)/(3*sqrt(x+1)))^3
return(byars_upper)
}
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100) {
rate <- x/n*multiplier
lowercl<-byars_lower(x)/n*multiplier
uppercl<-byars_upper(x)/n*multiplier
phe_rate <- c(rate, lowercl, uppercl)
return(phe_rate)
}
byars_lower(800)
phe_rate(800,10000,multiplier = 100000)
phe_proportion(6,100)
phe_proportion(6,100, 0.95)
phe_proportion(6,100, conf.int = 0.95)
# create phe_proportion function to execute binom.confint with method fixed to wilson
phe_proportion <- function(x, n, conf.level=0.95, percentage=FALSE) {
if (x < 0) {
stop("numerator must be greater than or equal to zero")
} else if (n <= 0) {
stop("denominator must be greater than zero")
} else if (x > n) {
stop("numerator must be less than or equal to denominator for a proportion statistic")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence interval must be between 90 and 99.99")
}
# scale confidence interval
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# set multiplier
multiplier <- 1
if (percentage == TRUE) {
multiplier <- 100
}
# calculate proportion and CIs
phe_proportion <- data.frame(binom.confint(x, n, conf.level, methods="wilson")) %>%
mutate(mean = mean * multiplier) %>%
mutate(lower = lower * multiplier) %>%
mutate(upper = upper * multiplier)
# set column names to be output
names(phe_proportion) <- c("method","numerator","denominator","proportion",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_proportion)
}
phe_proportion(6,100, conf.int = 0.95)
phe_proportion(6,100, conf.level = 0.95)
library(binom)
phe_proportion(6,100, conf.level = 0.95)
library(dplyr)
phe_proportion(6,100, conf.level = 0.95)
byars_lower <- function(x) {
byars_lower <- x*(1-1/(9*x)-qnorm(1-0.05/2)/(3*sqrt(x)))^3
return(byars_lower)
}
byars_upper <- function(x) {
byars_upper <- (x+1)*(1-1/(9*(x+1))+qnorm(1-0.05/2)/(3*sqrt(x+1)))^3
return(byars_upper)
}
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100) {
# add stops
rate <- x/n*multiplier
lowercl<-byars_lower(x)/n*multiplier
uppercl<-byars_upper(x)/n*multiplier
phe_rate <- c("Byars", x, n, rate, lowercl, uppercl)
names(phe_rate) <- c("method","numerator","denominator","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_rate)
}
phe_rate(65,100)
phe_proportion(65,100)
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100) {
# add stops
rate <- x/n*multiplier
lowercl<-byars_lower(x)/n*multiplier
uppercl<-byars_upper(x)/n*multiplier
phe_rate <- data.frame(c("Byars", x, n, rate, lowercl, uppercl))
names(phe_rate) <- c("method","numerator","denominator","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_rate)
}
phe_rate(65,100)
View(phe_rate)
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100) {
# add stops
#  rate <- x/n*multiplier
#  lowercl<-byars_lower(x)/n*multiplier
#  uppercl<-byars_upper(x)/n*multiplier
phe_rate <- data.frame(c("Byars", x, n, x / n * multiplier, byars_lower(x) / n * multiplier,byars_upper(x) / n * multiplier))
names(phe_rate) <- c("method","numerator","denominator","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_rate)
}
phe_rate(65,100)
?data.frame
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100) {
# add stops
#  rate <- x/n*multiplier
#  lowercl<-byars_lower(x)/n*multiplier
#  uppercl<-byars_upper(x)/n*multiplier
phe_rate <- data.frame(c("Byars", x, n, x / n * multiplier, byars_lower(x) / n * multiplier,byars_upper(x) / n * multiplier))
#  names(phe_rate) <- c("method","numerator","denominator","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_rate)
}
phe_rate(65,100)
binom.confint(65,100)
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100) {
# add stops
#  rate <- x/n*multiplier
#  lowercl<-byars_lower(x)/n*multiplier
#  uppercl<-byars_upper(x)/n*multiplier
phe_rate <- data.frame("Byars", x, n, x / n * multiplier, byars_lower(x) / n * multiplier,byars_upper(x) / n * multiplier)
#  names(phe_rate) <- c("method","numerator","denominator","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_rate)
}
phe_rate(65,100)
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100) {
# add stops
rate <- x/n*multiplier
lowercl<-byars_lower(x)/n*multiplier
uppercl<-byars_upper(x)/n*multiplier
phe_rate <- data.frame("Byars", x, n, rate, lowercl, uppercl)
#  names(phe_rate) <- c("method","numerator","denominator","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_rate)
}
phe_rate(65,100)
phe_rate(800,10000)
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100000) {
# add stops
rate <- x/n*multiplier
lowercl<-byars_lower(x)/n*multiplier
uppercl<-byars_upper(x)/n*multiplier
phe_rate <- data.frame("Byars", x, n, rate, lowercl, uppercl)
#  names(phe_rate) <- c("method","numerator","denominator","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_rate)
}
phe_rate(800,10000)
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100000) {
# add stops
rate <- x/n*multiplier
lowercl<-byars_lower(x)/n*multiplier
uppercl<-byars_upper(x)/n*multiplier
phe_rate <- data.frame("Byars", x, n, rate, lowercl, uppercl)
names(phe_rate) <- c("method","numerator","denominator","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_rate)
}
phe_rate(800,10000)
phe_dsr <- function(x,n,stdpop = esp2013, conf.level = 0.95, multiplier = 100000) {
# Calculate DSR
dsr <- sum(x * stdpop / n) / sum(stdpop)
# Calculate CIs using Byars function created in Rates.R
vardsr<-1/sum(stdpop)^2 * sum((stdpop^2 * x) / n^2)
vardsr
lowercl<- dsr + sqrt((vardsr/sum(x)))*(Byars_lower(sum(x))-sum(x))
lowercl
uppercl<- dsr + sqrt((vardsr/sum(x)))*(Byars_upper(sum(x))-sum(x))
uppercl
phe_dsr <- data.frame("Dobson",x, n, dsr, lowercl, uppercl)
names(phe_dsr) <- c("method","numerator","denominator","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
testpop <- c(84935,80367,72122,79259,99806,87362,81579,71103,
70001,69007,63203,52638,46087,40887,32604,28399,
21625,13021,7355)
testobs <- c(27,45,55,100,125,300,295,270,275,450,455,459,345,300,
270,265,100,90,35)
# define the function
phe_dsr <- function(x,n,stdpop = esp2013, conf.level = 0.95, multiplier = 100000) {
# Calculate DSR
dsr <- sum(x * stdpop / n) / sum(stdpop)
# Calculate CIs using Byars function created in Rates.R
vardsr<-1/sum(stdpop)^2 * sum((stdpop^2 * x) / n^2)
vardsr
lowercl<- dsr + sqrt((vardsr/sum(x)))*(Byars_lower(sum(x))-sum(x))
lowercl
uppercl<- dsr + sqrt((vardsr/sum(x)))*(Byars_upper(sum(x))-sum(x))
uppercl
phe_dsr <- data.frame("Dobson",x, n, dsr, lowercl, uppercl)
names(phe_dsr) <- c("method","numerator","denominator","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
phe_dsr(testobs,testpop)
head(testobs)
testobs
esp2013 <- c(5000,5500,5500,5500,6000,6000,6500,7000,7000,7000,7000,6500,6000,
5500,5000,4000,2500,1500,1000)
phe_dsr <- function(x,n,stdpop = esp2013, conf.level = 0.95, multiplier = 100000) {
# Calculate DSR
dsr <- sum(x * stdpop / n) / sum(stdpop)
# Calculate CIs using Byars function created in Rates.R
vardsr<-1/sum(stdpop)^2 * sum((stdpop^2 * x) / n^2)
vardsr
lowercl<- dsr + sqrt((vardsr/sum(x)))*(Byars_lower(sum(x))-sum(x))
lowercl
uppercl<- dsr + sqrt((vardsr/sum(x)))*(Byars_upper(sum(x))-sum(x))
uppercl
phe_dsr <- data.frame("Dobson",x, n, dsr, lowercl, uppercl)
names(phe_dsr) <- c("method","numerator","denominator","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
phe_dsr(testobs,testpop)
# define the function
phe_dsr <- function(x,n,stdpop = esp2013, conf.level = 0.95, multiplier = 100000) {
# Calculate DSR
dsr <- sum(x * stdpop / n) / sum(stdpop)
# Calculate CIs using Byars function created in Rates.R
vardsr<-1/sum(stdpop)^2 * sum((stdpop^2 * x) / n^2)
vardsr
lowercl<- dsr + sqrt((vardsr/sum(x)))*(byars_lower(sum(x))-sum(x))
lowercl
uppercl<- dsr + sqrt((vardsr/sum(x)))*(byars_upper(sum(x))-sum(x))
uppercl
phe_dsr <- data.frame("Dobson",x, n, dsr, lowercl, uppercl)
names(phe_dsr) <- c("method","numerator","denominator","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
phe_dsr(testobs,testpop)
# define the function
phe_dsr <- function(x,n,stdpop = esp2013, conf.level = 0.95, multiplier = 100000) {
# Calculate DSR
dsr <- sum(x * stdpop / n) / sum(stdpop)
# Calculate CIs using Byars function created in Rates.R
vardsr<-1/sum(stdpop)^2 * sum((stdpop^2 * x) / n^2)
vardsr
lowercl<- dsr + sqrt((vardsr/sum(x)))*(byars_lower(sum(x))-sum(x))
lowercl
uppercl<- dsr + sqrt((vardsr/sum(x)))*(byars_upper(sum(x))-sum(x))
uppercl
phe_dsr <- data.frame("Dobson",sum(x), sum(n), dsr, lowercl, uppercl)
names(phe_dsr) <- c("method","sum(numerator)","sum(denominator)","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
phe_dsr(testobs,testpop)
phe_dsr <- function(x,n,stdpop = esp2013, conf.level = 0.95, multiplier = 100000) {
# Calculate DSR
dsr <- sum(x * stdpop / n) / sum(stdpop) * multiplier
# Calculate CIs using Byars function created in Rates.R
vardsr<-1/sum(stdpop)^2 * sum((stdpop^2 * x) / n^2)
vardsr
lowercl<- dsr + sqrt((vardsr/sum(x)))*(byars_lower(sum(x))-sum(x)) * multiplier
lowercl
uppercl<- dsr + sqrt((vardsr/sum(x)))*(byars_upper(sum(x))-sum(x)) * multiplier
uppercl
phe_dsr <- data.frame("Dobson",sum(x), sum(n), dsr, lowercl, uppercl)
names(phe_dsr) <- c("method","sum(numerator)","sum(denominator)","rate",paste("lower",conf.level*100,"cl",sep=""),paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
phe_dsr(testobs,testpop)
library(readxl)
# import test data
DSR_testdata_small <- read_excel(".\\tests\\testdata\\DSR_TestData.xlsx", sheet=1, col_names=TRUE)
DSR_testdata_big <- read_excel(".\\tests\\testdata\\DSR_TestData.xlsx", sheet=3, col_names=TRUE)
# import test data
DSR_testdata_small <- read_excel(".\\tests\\testdata\\DSR_TestData.xlsx", sheet=1, col_names=TRUE)
DSR_testdata_big <- read_excel(".\\tests\\testdata\\DSR_TestData.xlsx", sheet=3, col_names=TRUE)
DSR_testdata_small <- read_excel(".\\tests\\testdata\\DSR_testdata.xlsx", sheet=1, col_names=TRUE)
DSR_testdata_big <- read_excel(".\\tests\\testdata\\DSR_testdata.xlsx", sheet=3, col_names=TRUE)
library(readxl)
DSR_testdata_small <- read_excel(".\\tests\\testdata\\DSR_testdata.xlsx", sheet=1, col_names=TRUE)
DSR_testdata_big <- read_excel(".\\tests\\testdata\\DSR_testdata.xlsx", sheet=3, col_names=TRUE)
#st the working directory
setwd("C:\Users\Georgina.Anderson\Documents\R\Projects\PHEstatmethods")
# import test data
DSR_testdata_small <- read_excel(".\\tests\\testdata\\DSR_testdata.xlsx", sheet=1, col_names=TRUE)
DSR_testdata_big <- read_excel(".\\tests\\testdata\\DSR_testdata.xlsx", sheet=3, col_names=TRUE)
#set the working directory
setwd("C:/Users/Georgina.Anderson/Documents/R/Projects/PHEstatmethods")
# import test data
DSR_testdata_small <- read_excel(".\\tests\\testdata\\DSR_testdata.xlsx", sheet=1, col_names=TRUE)
DSR_testdata_big <- read_excel(".\\tests\\testdata\\DSR_testdata.xlsx", sheet=3, col_names=TRUE)
DSR_testdata_small <- read_excel(".\\tests\\testthat\\DSR_testdata.xlsx", sheet=1, col_names=TRUE)
DSR_testdata_big <- read_excel(".\\tests\\testthat\\DSR_testdata.xlsx", sheet=3, col_names=TRUE)
install.packages("dsrTest")
library(dsrTest)
??dsrTest
View(DSR_testdata_small)
phe_dsr(DSR_testdata_small$count,DSR_testdata_small$pop,DSR_testdata_small$stdpop)
phe_dsr(DSR_testdata_small$count,DSR_testdata_small$pop,DSR_testdata_small$stdpop, multiplier=10000)
phe_dsr(DSR_testdata_big$count,DSR_testdata_big$pop,DSR_testdata_big$stdpop, multiplier=10000)
small_results <- phe_dsr(DSR_testdata_small$count,DSR_testdata_small$pop,DSR_testdata_small$stdpop, multiplier=10000)
big_results <- phe_dsr(DSR_testdata_big$count,DSR_testdata_big$pop,DSR_testdata_big$stdpop, multiplier=10000)
??dobsonControl
