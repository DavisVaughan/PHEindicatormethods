value = sum(wt_rate) / sum(stdpop_calc) * multiplier,
vardsr = 1/sum(stdpop_calc)^2 * sum(sq_rate),
lowercl = value + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = value + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%",sep=""),
statistic = paste("dsr per",format(multiplier,scientific=F)),
method = "Dobson")
phe_dsr$value[phe_dsr$total_count < 10]    <- NA
phe_dsr$uppercl[phe_dsr$total_count < 10]  <- NA
phe_dsr$lowercl[phe_dsr$total_count < 10]  <- NA
phe_dsr$statistic[phe_dsr$total_count <10] <- "dsr NA for total count < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 3),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence between 1 and 90")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 1000),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence >100")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, type="combined"),
"type must be one of value, lower, upper, standard or full",info="error invalid type")
expect_error(phe_dsr(filter(test_multiarea,count < 100), count, pop, stdpop = esp2013),
"data must contain the same number of rows for each group",info="error num rows per group")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = test_DSR_1976$stdpop),
"stdpop length must equal number of rows in each group within data",info="error stdpop length")
expect_error(phe_dsr(test_multiarea, count, pop, stdpoptype = "column"),
"stdpop length must equal number of rows in each group within data",info="error stdpoptype")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = test_DSR_1976$stdpop),
"stdpop length must equal number of rows in each group within data",info="error stdpop length")
phe_dsr(test_multiarea, count, pop, stdpop = test_DSR_1976$stdpop)
test_DSR_1976$stdpop
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = test_DSR_1976$esp1976),
"stdpop length must equal number of rows in each group within data",info="error stdpop length")
#test calculations
test_that("dsrs and CIs calculate correctly",{
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop)),
data.frame(select(test_DSR_results[9:11,],1,4:6)),
check.attributes=FALSE, check.names=FALSE,info="test default")
expect_equal(data.frame(phe_dsr(test_DSR_1976, count, pop, stdpop = test_DSR_1976$esp1976)),
select(slice(test_DSR_results,12),4:6),
check.attributes=FALSE, check.names=FALSE,info="test with user specified vector")
expect_equal(data.frame(phe_dsr(test_DSR_1976, count, pop, stdpop = esp1976, stdpoptype="field")),
data.frame(select(slice(test_DSR_results,12),4:6)),
check.attributes=FALSE, check.names=FALSE,info="test with user specified stdpop by col name")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop,
stdpop = c(5000, 5500, 5500, 5500, 6000, 6000, 6500, 7000, 7000, 7000, 7000, 6500, 6000, 5500, 5000, 4000, 2500, 1500, 1000))),
data.frame(select(slice(test_DSR_results,9:11),1,4:6)),
check.attributes=FALSE, check.names=FALSE,info="test stdpop as specified vector")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, type="full")),
data.frame(select(slice(test_DSR_results,9:11),1:9)),
check.attributes=FALSE, check.names=FALSE,info="test full")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, type="value")),
data.frame(select(slice(test_DSR_results,9:11),1,4)),
check.attributes=FALSE, check.names=FALSE,info="test value")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, type="lower")),
data.frame(select(slice(test_DSR_results,9:11),1,5)),
check.attributes=FALSE, check.names=FALSE,info="test lower")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, type="upper")),
data.frame(select(slice(test_DSR_results,9:11),1,6)),
check.attributes=FALSE, check.names=FALSE,info="test upper")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 0.998)),
data.frame(select(slice(test_DSR_results,13:15),1,4:6)),
check.attributes=FALSE, check.names=FALSE,info="test confidence")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, multiplier=10000)),
data.frame(select(slice(test_DSR_results,1:3),1,4:6)),
check.attributes=FALSE, check.names=FALSE,info="test multiplier")
})
test_that("dsrs - errors are generated when invalid arguments are used",{
expect_error(phe_dsr(test_multiarea, count),
"function phe_dsr requires at least 3 arguments: data, x, n",info="error invalid number of arguments")
expect_error(phe_dsr(test_err1, count, pop, stdpop = esp2013),
"numerators must all be greater than or equal to zero",info="error numerators < 0")
expect_error(phe_dsr(test_err2, count, pop, stdpop = esp2013),
"denominators must all be greater than zero",info="error denominator = 0")
expect_error(phe_dsr(test_err3, count, pop, stdpop = esp2013),
"denominators must all be greater than zero",info="error denominator < 0")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 0.74),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence < 0.9")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 3),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence between 1 and 90")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 1000),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence >100")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, type="combined"),
"type must be one of value, lower, upper, standard or full",info="error invalid type")
expect_error(phe_dsr(filter(test_multiarea,count < 100), count, pop, stdpop = esp2013),
"data must contain the same number of rows for each group",info="error num rows per group")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = test_DSR_1976$esp1976),
"stdpop length must equal number of rows in each group within data",info="error stdpop length")
expect_error(phe_dsr(test_multiarea, count, pop, stdpoptype = "column"),
"stdpop length must equal number of rows in each group within data",info="error stdpoptype")
expect_error(phe_dsr(test_DSR_1976, count, pop, stdpoptype = "field", stdpop = esp),
"stdpop is not a field name from data",info="error stdpop field doesn't exist")
})
# define the DSR function using Dobson method
phe_dsr <- function(data, x, n, stdpop = esp2013, stdpoptype = "vector", type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)) {
stop("function phe_dsr requires at least 3 arguments: data, x, n")
}
# check same number of rows per group
if (n_distinct(select(ungroup(summarise(data,n=n())),n)) != 1) {
stop("data must contain the same number of rows for each group")
}
# check stdpop is valid and append to data
if (!(stdpoptype %in% c("vector","field"))) {
stop("valid values for stdpoptype are vector and field")
} else if (stdpoptype == "vector") {
if (pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
data <- bind_cols(data,stdpop_calc = rep(stdpop,times=nrow(summarise(data,n=n()))))
} else if (stdpoptype == "field") {
enquostdpop <- enquo(stdpop)
if (deparse(substitute(stdpop)) %in% colnames(data)) {
data <- mutate(data,stdpop_calc = !!enquostdpop)
} else stop("stdpop is not a field name from data")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * stdpop_calc / (!!n),
sq_rate = (!!x) * (stdpop_calc/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
value = sum(wt_rate) / sum(stdpop_calc) * multiplier,
vardsr = 1/sum(stdpop_calc)^2 * sum(sq_rate),
lowercl = value + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = value + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%",sep=""),
statistic = paste("dsr per",format(multiplier,scientific=F)),
method = "Dobson")
phe_dsr$value[phe_dsr$total_count < 10]    <- NA
phe_dsr$uppercl[phe_dsr$total_count < 10]  <- NA
phe_dsr$lowercl[phe_dsr$total_count < 10]  <- NA
phe_dsr$statistic[phe_dsr$total_count <10] <- "dsr NA for total count < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
test_that("dsrs - errors are generated when invalid arguments are used",{
expect_error(phe_dsr(test_multiarea, count),
"function phe_dsr requires at least 3 arguments: data, x, n",info="error invalid number of arguments")
expect_error(phe_dsr(test_err1, count, pop, stdpop = esp2013),
"numerators must all be greater than or equal to zero",info="error numerators < 0")
expect_error(phe_dsr(test_err2, count, pop, stdpop = esp2013),
"denominators must all be greater than zero",info="error denominator = 0")
expect_error(phe_dsr(test_err3, count, pop, stdpop = esp2013),
"denominators must all be greater than zero",info="error denominator < 0")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 0.74),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence < 0.9")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 3),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence between 1 and 90")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 1000),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence >100")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, type="combined"),
"type must be one of value, lower, upper, standard or full",info="error invalid type")
expect_error(phe_dsr(filter(test_multiarea,count < 100), count, pop, stdpop = esp2013),
"data must contain the same number of rows for each group",info="error num rows per group")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = test_DSR_1976$esp1976),
"stdpop length must equal number of rows in each group within data",info="error stdpop length")
expect_error(phe_dsr(test_multiarea, count, pop, stdpoptype = "column"),
"stdpop length must equal number of rows in each group within data",info="error stdpoptype")
expect_error(phe_dsr(test_DSR_1976, count, pop, stdpoptype = "field", stdpop = esp),
"stdpop is not a field name from data",info="error stdpop field doesn't exist")
})
test_that("dsrs - errors are generated when invalid arguments are used",{
expect_error(phe_dsr(test_multiarea, count),
"function phe_dsr requires at least 3 arguments: data, x, n",info="error invalid number of arguments")
expect_error(phe_dsr(test_err1, count, pop, stdpop = esp2013),
"numerators must all be greater than or equal to zero",info="error numerators < 0")
expect_error(phe_dsr(test_err2, count, pop, stdpop = esp2013),
"denominators must all be greater than zero",info="error denominator = 0")
expect_error(phe_dsr(test_err3, count, pop, stdpop = esp2013),
"denominators must all be greater than zero",info="error denominator < 0")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 0.74),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence < 0.9")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 3),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence between 1 and 90")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 1000),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence >100")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, type="combined"),
"type must be one of value, lower, upper, standard or full",info="error invalid type")
expect_error(phe_dsr(filter(test_multiarea,count < 100), count, pop, stdpop = esp2013),
"data must contain the same number of rows for each group",info="error num rows per group")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = test_DSR_1976$esp1976),
"stdpop length must equal number of rows in each group within data",info="error stdpop length")
expect_error(phe_dsr(test_multiarea, count, pop, stdpoptype = "column"),
"valid values for stdpoptype are vector and field",info="error stdpoptype")
expect_error(phe_dsr(test_DSR_1976, count, pop, stdpoptype = "field", stdpop = esp),
"stdpop is not a field name from data",info="error stdpop field doesn't exist")
})
#test calculations
test_that("dsrs and CIs calculate correctly",{
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop)),
data.frame(select(test_DSR_results[9:11,],1,4:6)),
check.attributes=FALSE, check.names=FALSE,info="test default")
expect_equal(data.frame(phe_dsr(test_DSR_1976, count, pop, stdpop = test_DSR_1976$esp1976)),
select(slice(test_DSR_results,12),4:6),
check.attributes=FALSE, check.names=FALSE,info="test with user specified vector")
expect_equal(data.frame(phe_dsr(test_DSR_1976, count, pop, stdpop = esp1976, stdpoptype="field")),
data.frame(select(slice(test_DSR_results,12),4:6)),
check.attributes=FALSE, check.names=FALSE,info="test with user specified stdpop by col name")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop,
stdpop = c(5000, 5500, 5500, 5500, 6000, 6000, 6500, 7000, 7000, 7000, 7000, 6500, 6000, 5500, 5000, 4000, 2500, 1500, 1000))),
data.frame(select(slice(test_DSR_results,9:11),1,4:6)),
check.attributes=FALSE, check.names=FALSE,info="test stdpop as specified vector")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, type="full")),
data.frame(select(slice(test_DSR_results,9:11),1:9)),
check.attributes=FALSE, check.names=FALSE,info="test full")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, type="value")),
data.frame(select(slice(test_DSR_results,9:11),1,4)),
check.attributes=FALSE, check.names=FALSE,info="test value")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, type="lower")),
data.frame(select(slice(test_DSR_results,9:11),1,5)),
check.attributes=FALSE, check.names=FALSE,info="test lower")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, type="upper")),
data.frame(select(slice(test_DSR_results,9:11),1,6)),
check.attributes=FALSE, check.names=FALSE,info="test upper")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 0.998)),
data.frame(select(slice(test_DSR_results,13:15),1,4:6)),
check.attributes=FALSE, check.names=FALSE,info="test confidence")
expect_equal(data.frame(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, multiplier=10000)),
data.frame(select(slice(test_DSR_results,1:3),1,4:6)),
check.attributes=FALSE, check.names=FALSE,info="test multiplier")
})
test_that("dsrs - errors are generated when invalid arguments are used",{
expect_error(phe_dsr(test_multiarea, count),
"function phe_dsr requires at least 3 arguments: data, x, n",info="error invalid number of arguments")
expect_error(phe_dsr(test_err1, count, pop, stdpop = esp2013),
"numerators must all be greater than or equal to zero",info="error numerators < 0")
expect_error(phe_dsr(test_err2, count, pop, stdpop = esp2013),
"denominators must all be greater than zero",info="error denominator = 0")
expect_error(phe_dsr(test_err3, count, pop, stdpop = esp2013),
"denominators must all be greater than zero",info="error denominator < 0")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 0.74),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence < 0.9")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 3),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence between 1 and 90")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, confidence = 1000),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence >100")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = esp2013, type="combined"),
"type must be one of value, lower, upper, standard or full",info="error invalid type")
expect_error(phe_dsr(filter(test_multiarea,count < 100), count, pop, stdpop = esp2013),
"data must contain the same number of rows for each group",info="error num rows per group")
expect_error(phe_dsr(test_multiarea, count, pop, stdpop = test_DSR_1976$esp1976),
"stdpop length must equal number of rows in each group within data",info="error stdpop length")
expect_error(phe_dsr(test_multiarea, count, pop, stdpoptype = "column"),
"valid values for stdpoptype are vector and field",info="error stdpoptype")
expect_error(phe_dsr(test_DSR_1976, count, pop, stdpoptype = "field", stdpop = esp),
"stdpop is not a field name from data",info="error stdpop field doesn't exist")
})
#test calculations
test_that("means and CIs calculate correctly",{
expect_equal(data.frame(phe_mean(test_Mean,values)),
data.frame(select(slice(test_Mean_results,3),5:7)),check.attributes=FALSE, check.names=FALSE,info="test default")
expect_equal(data.frame(phe_mean(test_Mean_Grp,values)),
data.frame(select(slice(test_Mean_results,1:2),1,5:7)),check.attributes=FALSE, check.names=FALSE,info="test default grouped")
expect_equal(data.frame(phe_mean(test_Mean_Grp,values, type="full")),
data.frame(slice(test_Mean_results,1:2)),check.attributes=FALSE, check.names=FALSE,info="test full")
expect_equal(data.frame(phe_mean(test_Mean_Grp,values, type="value")),
data.frame(select(slice(test_Mean_results,1:2),1,5)),check.attributes=FALSE, check.names=FALSE,info="test value")
expect_equal(data.frame(phe_mean(test_Mean_Grp,values, type="lower")),
data.frame(select(slice(test_Mean_results,1:2),1,6)),check.attributes=FALSE, check.names=FALSE,info="test lower")
expect_equal(data.frame(phe_mean(test_Mean_Grp,values, type="upper")),
data.frame(select(slice(test_Mean_results,1:2),1,7)),check.attributes=FALSE, check.names=FALSE,info="test upper")
expect_equal(data.frame(phe_mean(test_Mean_Grp,values, confidence = 99.8)),
data.frame(select(slice(test_Mean_results,4:5),1,5:7)),check.attributes=FALSE, check.names=FALSE,info="test confidence")
})
#test error handling
test_that("means - errors are generated when invalid arguments are used",{
expect_error(phe_mean(test_Mean),
"function phe_dsr requires at least 2 arguments: data, x",info="error invalid number of arguments")
expect_error(phe_mean(test_Mean, values, confidence = 0.2),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence < 0.9")
expect_error(phe_mean(test_Mean, values, confidence = 202),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence between 1 and 90")
expect_error(phe_mean(test_Mean, values, confidence = 200),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence > 100")
expect_error(phe_mean(test_Mean, values, type="combined"),
"type must be one of value, lower, upper, standard or full",info="error invalid type")
})
expect_equal(phe_proportion(slice(test_Prop,1:8)[1:3], Numerator, Denominator),
select(slice(test_Prop,1:8),1:6),check.attributes=FALSE, check.names=FALSE, info="test default")
# Proportions
test_Prop   <- read_excel(".\\tests\\testthat\\testdata_Proportion.xlsx", sheet="testdata_Prop",   col_names=TRUE)
#Rates
test_Rate <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx", sheet="testdata_Rate", col_names=TRUE)
#Means
test_Mean         <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean",         col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean_results", col_names=TRUE)
test_Mean_Grp <- group_by(test_Mean,area)
# DSRs, ISRs and SMRs
test_multiarea   <- read_excel(".\\tests\\testthat\\testdata_DSR_ISR_SMR.xlsx", sheet="testdata_multiarea", col_names=TRUE) %>%
group_by(area)
test_DSR_1976    <- read_excel(".\\tests\\testthat\\testdata_DSR_ISR_SMR.xlsx", sheet="testdata_1976",   col_names=TRUE)
test_err1        <- read_excel(".\\tests\\testthat\\testdata_DSR_ISR_SMR.xlsx", sheet="testdata_err1",   col_names=TRUE)
test_err2        <- read_excel(".\\tests\\testthat\\testdata_DSR_ISR_SMR.xlsx", sheet="testdata_err2",   col_names=TRUE) %>%
group_by(area)
test_err3        <- read_excel(".\\tests\\testthat\\testdata_DSR_ISR_SMR.xlsx", sheet="testdata_err3",   col_names=TRUE)
test_DSR_results <- read_excel(".\\tests\\testthat\\testdata_DSR_ISR_SMR.xlsx", sheet="testresults_DSR", col_names=TRUE)
test_multigroup  <- read_excel(".\\tests\\testthat\\testdata_DSR_ISR_SMR.xlsx", sheet="testdata_multigroup", col_names=TRUE) %>%
group_by(area,year)
test_ISR_results <- read_excel(".\\tests\\testthat\\testdata_DSR_ISR_SMR.xlsx", sheet="testresults_ISR", col_names=TRUE)
test_ISR_refdata <- read_excel(".\\tests\\testthat\\testdata_DSR_ISR_SMR.xlsx", sheet="refdata",         col_names=TRUE)
test_ISR_ownref  <- read_excel(".\\tests\\testthat\\testdata_DSR_ISR_SMR.xlsx", sheet="testdata_multiarea_ref", col_names=TRUE) %>%
group_by(area)
# use this code to save loaded data to sysdata folder:
devtools::use_data(test_Prop,
test_Rate,
test_Mean, test_Mean_Grp, test_Mean_results,
test_multiarea, test_multigroup, test_DSR_1976, test_err1, test_err2, test_err3, test_DSR_results,
test_ISR_refdata, test_ISR_results, test_ISR_ownref,
internal = TRUE, overwrite = TRUE)
expect_equal(phe_proportion(slice(test_Prop,1:8)[1:3], Numerator, Denominator),
select(slice(test_Prop,1:8),1:6),check.attributes=FALSE, check.names=FALSE, info="test default")
# Proportions
test_Prop   <- read_excel(".\\tests\\testthat\\testdata_Proportion.xlsx", sheet="testdata_Prop",   col_names=TRUE)
#Rates
test_Rate <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx", sheet="testdata_Rate", col_names=TRUE)
#Means
test_Mean         <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean",         col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean_results", col_names=TRUE)
test_Mean_Grp <- group_by(test_Mean,area)
expect_equal(phe_proportion(slice(test_Prop,1:8)[1:3], Numerator, Denominator),
select(slice(test_Prop,1:8),1:6),check.attributes=FALSE, check.names=FALSE, info="test default")
expect_equal(phe_proportion(slice(test_Prop,9:16)[1:3], Numerator, Denominator,
percentage = TRUE, type="full"),
select(slice(test_Prop,9:16),1:9),check.attributes=FALSE, check.names=FALSE, info="test full, percentage")
expect_equal(phe_proportion(slice(test_Prop,1:8)[1:3], Numerator, Denominator,
percentage=FALSE, type="full"),
select(slice(test_Prop,1:8),1:9),check.attributes=FALSE, check.names=FALSE, info="test full")
expect_equal(phe_proportion(slice(test_Prop,17:24)[1:3], Numerator, Denominator,
type="full", confidence=99.8),
select(slice(test_Prop,17:24),1:9),check.attributes=FALSE, check.names=FALSE, info="test confidence")
expect_equal(data.frame(phe_proportion(slice(test_Prop,17:24)[1:3], Numerator, Denominator,
type="full", confidence=99.8)),
data.frame(select(slice(test_Prop,17:24),1:9)),check.attributes=FALSE, check.names=FALSE, info="test confidence")
expect_equal(phe_proportion(slice(test_Prop,1:8)[1:3], Numerator, Denominator, type="value"),
select(slice(test_Prop,1:8),1:4),check.attributes=FALSE, check.names=FALSE, info="test value")
expect_equal(phe_proportion(slice(test_Prop,1:8)[1:3], Numerator, Denominator, type="lower"),
select(slice(test_Prop,1:8),1:3,5),check.attributes=FALSE, check.names=FALSE, info="test lower")
expect_equal(phe_proportion(slice(test_Prop,1:8)[1:3], Numerator, Denominator, type="upper"),
select(slice(test_Prop,1:8),1:3,6),check.attributes=FALSE, check.names=FALSE, info="test upper")
test_that("proportions - errors are generated when invalid arguments are used",{
expect_error(phe_proportion(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs),
"function phe_dsr requires at least 3 arguments: data, x, n", info="error not enough arguments")
expect_error(phe_proportion(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,-80,30),
pop =c(100,100,100)), obs, pop),
"numerators must be greater than or equal to zero", info="error num < 0")
expect_error(phe_proportion(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,0,100)), obs, pop),
"denominators must be greater than zero", info="error denom = 0")
expect_error(phe_proportion(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,-100)), obs, pop),
"denominators must be greater than zero", info="error denom < 0")
expect_error(phe_proportion(data.frame(area=c("Area1","Area2","Area3"),
obs =c(101,80,30),
pop =c(100,100,100)), obs, pop),
"numerators must be less than or equal to denominator for a proportion statistic", info="error ")
expect_error(phe_proportion(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs, pop, confidence = 0.8),
"confidence level must be between 90 and 100 or between 0.9 and 1", info="error conf < 0.9")
expect_error(phe_proportion(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs, pop, confidence = 50),
"confidence level must be between 90 and 100 or between 0.9 and 1", info="error conf between 1 and 90")
expect_error(phe_proportion(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs, pop, confidence = 130),
"confidence level must be between 90 and 100 or between 0.9 and 1", info="error conf >100")
expect_error(phe_proportion(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs, pop, type="combined"),
"type must be one of value, lower, upper, standard or full", info="error invalid type")
})
#test calculations
test_that("rates and CIs calculate correctly",{
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator),
select(slice(test_Rate,9:16),1:6),check.attributes=FALSE, check.names=FALSE, info="test default")
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="full"),
select(slice(test_Rate,9:16),1:9),check.attributes=FALSE, check.names=FALSE, info="test full")
expect_equal(phe_rate(slice(test_Rate,25:32)[1:3],Numerator,Denominator, confidence=99.8),
select(slice(test_Rate,25:32),1:6),check.attributes=FALSE, check.names=FALSE, info="test confidence")
expect_equal(phe_rate(slice(test_Rate,1:8)[1:3],Numerator,Denominator, multiplier=100),
select(slice(test_Rate,1:8),1:6),check.attributes=FALSE, check.names=FALSE, info="test multiplier")
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="value"),
select(slice(test_Rate,9:16),1:4),check.attributes=FALSE, check.names=FALSE, info="test value")
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="lower"),
select(slice(test_Rate,9:16),1:3,5),check.attributes=FALSE, check.names=FALSE, info="test lower")
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="upper"),
select(slice(test_Rate,9:16),1:3,6),check.attributes=FALSE, check.names=FALSE, info="test upper")
})
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator),
select(slice(test_Rate,9:16),1:6),check.attributes=FALSE, check.names=FALSE, info="test default")
#test calculations
test_that("rates and CIs calculate correctly",{
expect_equal(data.frame(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator)),
data.frame(select(slice(test_Rate,9:16),1:6)),check.attributes=FALSE, check.names=FALSE, info="test default")
expect_equal(data.frame(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="full")),
data.frame(select(slice(test_Rate,9:16),1:9)),check.attributes=FALSE, check.names=FALSE, info="test full")
expect_equal(data.frame(phe_rate(slice(test_Rate,25:32)[1:3],Numerator,Denominator, confidence=99.8)),
data.frame(select(slice(test_Rate,25:32),1:6)),check.attributes=FALSE, check.names=FALSE, info="test confidence")
expect_equal(data.frame(phe_rate(slice(test_Rate,1:8)[1:3],Numerator,Denominator, multiplier=100)),
data.frame(select(slice(test_Rate,1:8),1:6)),check.attributes=FALSE, check.names=FALSE, info="test multiplier")
expect_equal(data.frame(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="value")),
data.frame(select(slice(test_Rate,9:16),1:4)),check.attributes=FALSE, check.names=FALSE, info="test value")
expect_equal(data.frame(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="lower")),
data.frame(select(slice(test_Rate,9:16),1:3,5)),check.attributes=FALSE, check.names=FALSE, info="test lower")
expect_equal(data.frame(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="upper")),
data.frame(select(slice(test_Rate,9:16),1:3,6)),check.attributes=FALSE, check.names=FALSE, info="test upper")
})
# test error handling
test_that("rates - errors are generated when invalid arguments are used",{
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs),
"function phe_dsr requires at least 3 arguments: data, x, n", info="error invalid number of arguments")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(-65,80,30),
pop =c(100,100,100)), obs, pop),
"numerators must be greater than or equal to zero", info="error num < 0")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,0)), obs, pop),
"denominators must be greater than zero", info="error denom = 0")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,-100,100)), obs, pop),
"denominators must be greater than zero", info="error denom < 0")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs, pop, confidence = 0.5),
"confidence level must be between 90 and 100 or between 0.9 and 1", info="error confidence < 0.9")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs, pop, confidence = 40),
"confidence level must be between 90 and 100 or between 0.9 and 1", info="error confidence between 1 and 90")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs, pop, confidence = 9998),
"confidence level must be between 90 and 100 or between 0.9 and 1", info="error confidence >100")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs, pop, type="combined"),
"type must be one of value, lower, upper, standard or full", info="error invalid type")
})
?phe_dsr
knitr::opts_chunk$set(
collapse = TRUE,
error = TRUE,
comment = "#>"
)
pops2   <- data.frame(AgeBand    = c( 0, 5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90),
Population = c(30,35,35,35,40,40,45,50,50,50,60,60,70,75,70,60,20,20,15))
deaths2 <- data.frame(AgeBand = c(0,5,25,30,35,40,45,50,55,60,65,70,75,80,85,90),
Dths    = c(1,1, 1, 1, 3, 3, 3, 3,10,10,10,10, 8, 8, 8, 8))
phe_dsr(data_nodths, Dths, Population)
phe_dsr(data2, Dths, Population)
phe_dsr(df2, Dths, Population)
df2 <- left_join(pops2, deaths2, by="AgeBand")
phe_dsr(df2, Dths, Population)
df3 <- df2 %>%
mutate(Dths = replace(Dths, which(is.na(Dths)), 0))
phe_dsr(data_nodths, Dths, Population)
phe_dsr(df3, Dths, Population)
View(df2)
