} else if (any(n <= 0)) {
stop("denominators must all be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be >= 90 and <= 100 (or >= 0.9 and <= 1)")
} else if (length(x) != length(n)) {
stop("numerator and denominator vectors must be of equal length")
} else if (length(x) %% length(stdpop) !=0) {
stop("numerator vector length must be a multiple of standard population vector length")
} else if (sum(x) < 10) {
stop("DSR calculation is not valid for total counts < 10")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
name_lower <- paste("lower",conf.level*100,"cl",sep="")
name_upper <- paste("upper",conf.level*100,"cl",sep="")
# calculate DSR and CIs
phe_dsr <- data.frame(x, n, stdpop, groupref) %>%
group_by(groupref) %>%
mutate(wt_rate = x * stdpop / n,
sq_rate = x * (stdpop/n)^2) %>%
summarise(total_count = sum(x),
total_pop = sum(n),
dsr = sum(wt_rate) / sum(stdpop) * multiplier,
vardsr = 1/sum(stdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(x)))*(byars_lower(sum(x),conf.level)-sum(x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(x)))*(byars_upper(sum(x),conf.level)-sum(x)) * multiplier) %>%
mutate(method = "Dobson") %>%
select(method, total_count, total_pop, dsr, lowercl, uppercl) %>%
rename(name_lower = "lowercl",
name_upper = "uppercl")
#  names(phe_dsr) <- c("method", "total_count", "total_pop", "dsr",
#                      paste("lower",conf.level*100,"cl",sep=""),
#                      paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
phe_dsr(testdata_DSR_multiarea$count,testdata_DSR_multiarea$pop,groupref=testdata_DSR_multiarea$area)
phe_dsr <- function(x,n,stdpop = esp2013, groupref = NULL, conf.level = 0.95, multiplier = 100000) {
# validate arguments
if (any(x < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(n <= 0)) {
stop("denominators must all be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be >= 90 and <= 100 (or >= 0.9 and <= 1)")
} else if (length(x) != length(n)) {
stop("numerator and denominator vectors must be of equal length")
} else if (length(x) %% length(stdpop) !=0) {
stop("numerator vector length must be a multiple of standard population vector length")
} else if (sum(x) < 10) {
stop("DSR calculation is not valid for total counts < 10")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
name_lower <- paste("lower",conf.level*100,"cl",sep="")
name_upper <- paste("upper",conf.level*100,"cl",sep="")
# calculate DSR and CIs
phe_dsr <- data.frame(x, n, stdpop, groupref) %>%
group_by(groupref) %>%
mutate(wt_rate = x * stdpop / n,
sq_rate = x * (stdpop/n)^2) %>%
summarise(total_count = sum(x),
total_pop = sum(n),
dsr = sum(wt_rate) / sum(stdpop) * multiplier,
vardsr = 1/sum(stdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(x)))*(byars_lower(sum(x),conf.level)-sum(x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(x)))*(byars_upper(sum(x),conf.level)-sum(x)) * multiplier) %>%
mutate(method = "Dobson") %>%
select(method, total_count, total_pop, dsr, lowercl, uppercl)
names(phe_dsr) <- c("method", "total_count", "total_pop", "dsr",
paste("lower",conf.level*100,"cl",sep=""),
paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
View(testdata_results)
testdata_results       <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",   col_names=TRUE)
View(testdata_results)
expect_equal(phe_dsr(testdata_DSR_multiarea$count,testdata_DSR_multiarea$pop,groupref=testdata_DSR_multiarea$area)[2:6],
select(testdata_results,c(2,3,4,5,6)),check.attributes=FALSE, check.names=FALSE)
select(testdata_results,c(2,3,4,5,6))
phe_dsr(testdata_DSR_multiarea$count,testdata_DSR_multiarea$pop,groupref=testdata_DSR_multiarea$area)[2:6]
testdata_results       <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",   col_names=TRUE)
expect_equal(phe_dsr(testdata_DSR_multiarea$count,testdata_DSR_multiarea$pop,groupref=testdata_DSR_multiarea$area)[2:6],
select(testdata_results,c(2,3,4,5,6)),check.attributes=FALSE, check.names=FALSE)
select(testdata_results,c(2,3,4,5,6))
phe_dsr(testdata_DSR_multiarea$count,testdata_DSR_multiarea$pop,groupref=testdata_DSR_multiarea$area)[2:6]
expect_equal(phe_dsr(testdata_DSR_multiarea$count,testdata_DSR_multiarea$pop,groupref=testdata_DSR_multiarea$area,multiplier=10000)[2:6],
select(testdata_results,c(2,3,4,5,6)),check.attributes=FALSE, check.names=FALSE)
devtools::document
devtools::document()
phe_dsr(testdata_DSR_big$count,testdata_DSR_big$pop)
View(testdata_DSR_big)
phe_dsr <- function(x,n,stdpop = esp2013, groupref = NULL, conf.level = 0.95, multiplier = 100000) {
# validate arguments
if (any(x < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(n <= 0)) {
stop("denominators must all be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be >= 90 and <= 100 (or >= 0.9 and <= 1)")
} else if (length(x) != length(n)) {
stop("numerator and denominator vectors must be of equal length")
} else if (length(x) %% length(stdpop) !=0) {
stop("numerator vector length must be a multiple of standard population vector length")
} else if (sum(x) < 10) {
stop("DSR calculation is not valid for total counts < 10")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate DSR and CIs
phe_dsr <- data.frame(x, n, stdpop, groupref) %>%
group_by(groupref) %>%
mutate(wt_rate = x * stdpop / n,
sq_rate = x * (stdpop/n)^2) %>%
summarise(total_count = sum(x),
total_pop = sum(n),
dsr = sum(wt_rate) / sum(stdpop) * multiplier,
vardsr = 1/sum(stdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(x)))*(byars_lower(sum(x),conf.level)-sum(x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(x)))*(byars_upper(sum(x),conf.level)-sum(x)) * multiplier) %>%
mutate(method = "Dobson") %>%
select(method, total_count, total_pop, dsr, lowercl, uppercl)
names(phe_dsr) <- c("method", "total_count", "total_pop", "dsr",
paste("lower",conf.level*100,"cl",sep=""),
paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
testdata_DSR_big$count
testdata_DSR_big$pop
phe_dsr(testdata_DSR_big$count,testdata_DSR_big$pop)
phe_dsr <- function(x,n,stdpop = esp2013, groupref = 1, conf.level = 0.95, multiplier = 100000) {
# validate arguments
if (any(x < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(n <= 0)) {
stop("denominators must all be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be >= 90 and <= 100 (or >= 0.9 and <= 1)")
} else if (length(x) != length(n)) {
stop("numerator and denominator vectors must be of equal length")
} else if (length(x) %% length(stdpop) !=0) {
stop("numerator vector length must be a multiple of standard population vector length")
} else if (sum(x) < 10) {
stop("DSR calculation is not valid for total counts < 10")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate DSR and CIs
phe_dsr <- data.frame(x, n, stdpop, groupref) %>%
group_by(groupref) %>%
mutate(wt_rate = x * stdpop / n,
sq_rate = x * (stdpop/n)^2) %>%
summarise(total_count = sum(x),
total_pop = sum(n),
dsr = sum(wt_rate) / sum(stdpop) * multiplier,
vardsr = 1/sum(stdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(x)))*(byars_lower(sum(x),conf.level)-sum(x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(x)))*(byars_upper(sum(x),conf.level)-sum(x)) * multiplier) %>%
mutate(method = "Dobson") %>%
select(method, total_count, total_pop, dsr, lowercl, uppercl)
names(phe_dsr) <- c("method", "total_count", "total_pop", "dsr",
paste("lower",conf.level*100,"cl",sep=""),
paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
phe_dsr(testdata_DSR_big$count,testdata_DSR_big$pop)
phe_dsr(testdata_DSR_small$count,testdata_DSR_small$pop)
expect_equal(phe_dsr(testdata_DSR_multiarea$count,testdata_DSR_multiarea$pop,groupref=testdata_DSR_multiarea$area,multiplier=10000)[2:6],
select(testdata_results,c(2,3,4,5,6)),check.attributes=FALSE, check.names=FALSE)
rm(list=ls()
)
devtools::load_all()
devtools::test()
library(PHEstatmethods)
install.packages("Rtools")
library(PHEstatmethods)
phe_rate(65,100)
?PHEstatmethods
??PHEstatmethods
?phe_proportion
expect_equal(phe_rate(testdata_Rate_100000$Numerator,testdata_Rate_100000$Denominator,
multiplier=100000)[2:6],
select(testdata_Rate_100000,c(1,2,4,5,6)),check.attributes=FALSE, check.names=FALSE)
phe_rate(65,100)
library(testthat)
devtools::document()
library(readxl)
library(testthat)
expect_equal(phe_rate(testdata_Rate_100$Numerator,testdata_Rate_100$Denominator,multiplier=100)[2:6],
select(testdata_Rate_100,c(1,2,4,5,6)),check.attributes=FALSE, check.names=FALSE)
testdata_Rate_100000 <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx",
sheet="testdata_Rate_100000", col_names=TRUE)
testdata_Rate_100 <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx",
sheet="testdata_Rate_100", col_names=TRUE)
expect_equal(phe_rate(testdata_Rate_100$Numerator,testdata_Rate_100$Denominator,multiplier=100)[2:6],
select(testdata_Rate_100,c(1,2,4,5,6)),check.attributes=FALSE, check.names=FALSE)
library(PHEstatmethods)
expect_equal(phe_rate(testdata_Rate_100$Numerator,testdata_Rate_100$Denominator,multiplier=100)[2:6],
select(testdata_Rate_100,c(1,2,4,5,6)),check.attributes=FALSE, check.names=FALSE)
phe_rate <- function(x, n, conf.level = 0.95, multiplier = 100000) {
# validate arguments
if (any(x < 0)) {
stop("numerators must be greater than or equal to zero")
} else if (any(n <= 0)) {
stop("denominators must be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be >= 90 and <= 100 (or >= 0.9 and <= 1)")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate rate and CIs
rate <- x/n*multiplier
# apply different CI method for x < 10 and x >= 10
lowercl <- numeric()
uppercl <- numeric()
for (i in 1:length(x)) {
if (x[i] < 10) {
lowercl_tmp <- qchisq((1-conf.level)/2,2*x[i])/2/n[i]*multiplier
uppercl_tmp <- qchisq(conf.level+(1-conf.level)/2,2*x[i]+2)/2/n[i]*multiplier
} else lowercl_tmp <- byars_lower(x[i],conf.level)/n[i]*multiplier
uppercl_tmp <- byars_upper(x[i],conf.level)/n[i]*multiplier
lowercl <- rbind(lowercl,lowercl_tmp)
uppercl <- rbind(uppercl,uppercl_tmp)
}
# construct output
phe_rate <- data.frame("Byars", x, n, rate, lowercl, uppercl)
names(phe_rate) <- c("method","numerator","denominator","rate",
paste("lower",conf.level*100,"cl",sep=""),
paste("upper",conf.level*100,"cl",sep=""))
return(phe_rate)
}
expect_equal(phe_rate(testdata_Rate_100$Numerator,testdata_Rate_100$Denominator,multiplier=100)[2:6],
select(testdata_Rate_100,c(1,2,4,5,6)),check.attributes=FALSE, check.names=FALSE)
rm(list=ls())
library(PHEstatmethods)
phe_rate(65,100)
library(PHEstatmethods)
phe_rate(65,100)
devtools::document()
library(PHEstatmethods)
phe_rate(65,100)
library(testthat)
testdata_Rate_100000 <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx",
sheet="testdata_Rate_100000", col_names=TRUE)
testdata_Rate_100 <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx",
sheet="testdata_Rate_100", col_names=TRUE)
library(readxl)
testdata_Rate_100000 <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx",
sheet="testdata_Rate_100000", col_names=TRUE)
testdata_Rate_100 <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx",
sheet="testdata_Rate_100", col_names=TRUE)
expect_equal(phe_rate(testdata_Rate_100$Numerator,testdata_Rate_100$Denominator,multiplier=100)[2:6],
select(testdata_Rate_100,c(1,2,4,5,6)),check.attributes=FALSE, check.names=FALSE)
phe_rate(testdata_Rate_100$Numerator,testdata_Rate_100$Denominator,multiplier=100)[2:6]
select(testdata_Rate_100,c(1,2,4,5,6))
library(dplyr)
expect_equal(phe_rate(testdata_Rate_100$Numerator,testdata_Rate_100$Denominator,multiplier=100)[2:6],
select(testdata_Rate_100,c(1,2,4,5,6)),check.attributes=FALSE, check.names=FALSE)
phe_rate(testdata_Rate_100$Numerator,testdata_Rate_100$Denominator,multiplier=100)[2:6]
select(testdata_Rate_100,c(1,2,4,5,6))
expect_equal(phe_dsr(testdata_DSR_multiarea$count,testdata_DSR_multiarea$pop,groupref=testdata_DSR_multiarea$area,multiplier=10000)[2:6],
select(testdata_results,c(2,3,4,5,6)),check.attributes=FALSE, check.names=FALSE)
library(PHEstatmethods)
testdata_DSR_multiarea <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_multiarea", col_names=TRUE)
testdata_results       <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",   col_names=TRUE)
expect_equal(phe_dsr(testdata_DSR_multiarea$count,testdata_DSR_multiarea$pop,groupref=testdata_DSR_multiarea$area,multiplier=10000)[2:6],
select(testdata_results,c(2,3,4,5,6)),check.attributes=FALSE, check.names=FALSE)
devtools::document()
library(PHEstatmethods)
library(testthat)
library(readxl)
testdata_DSR_multiarea <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_multiarea", col_names=TRUE)
testdata_results       <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",   col_names=TRUE)
expect_equal(phe_dsr(testdata_DSR_multiarea$count,testdata_DSR_multiarea$pop,groupref=testdata_DSR_multiarea$area,multiplier=10000)[2:6],
select(testdata_results,c(2,3,4,5,6)),check.attributes=FALSE, check.names=FALSE)
View(testdata_DSR_multiarea)
phe_dsr(testdata_DSR_multiarea$count,testdata_DSR_multiarea$pop,groupref=testdata_DSR_multiarea$area,multiplier=10000)
phe_dsr <- function(x,n,stdpop = esp2013, groupref = 1, conf.level = 0.95, multiplier = 100000) {
# validate arguments
if (any(x < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(n <= 0)) {
stop("denominators must all be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be >= 90 and <= 100 (or >= 0.9 and <= 1)")
} else if (length(x) != length(n)) {
stop("numerator and denominator vectors must be of equal length")
} else if (length(x) %% length(stdpop) !=0) {
stop("numerator vector length must be a multiple of standard population vector length")
} else if (sum(x) < 10) {
stop("DSR calculation is not valid for total counts < 10")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate DSR and CIs
phe_dsr <- data.frame(x, n, stdpop, groupref) %>%
group_by(groupref) %>%
mutate(wt_rate = x * stdpop / n,
sq_rate = x * (stdpop/n)^2) %>%
summarise(total_count = sum(x),
total_pop = sum(n),
dsr = sum(wt_rate) / sum(stdpop) * multiplier,
vardsr = 1/sum(stdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(x)))*(byars_lower(sum(x),conf.level)-sum(x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(x)))*(byars_upper(sum(x),conf.level)-sum(x)) * multiplier) %>%
mutate(method = "Dobson") %>%
select(method, total_count, total_pop, dsr, lowercl, uppercl)
names(phe_dsr) <- c("method", "total_count", "total_pop", "dsr",
paste("lower",conf.level*100,"cl",sep=""),
paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
phe_dsr <- function(x,n,stdpop = esp2013, groupref = "All", conf.level = 0.95, multiplier = 100000) {
# validate arguments
if (any(x < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(n <= 0)) {
stop("denominators must all be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be >= 90 and <= 100 (or >= 0.9 and <= 1)")
} else if (length(x) != length(n)) {
stop("numerator and denominator vectors must be of equal length")
} else if (length(x) %% length(stdpop) !=0) {
stop("numerator vector length must be a multiple of standard population vector length")
} else if (sum(x) < 10) {
stop("DSR calculation is not valid for total counts < 10")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate DSR and CIs
phe_dsr <- data.frame(x, n, stdpop, groupref) %>%
group_by(groupref) %>%
mutate(wt_rate = x * stdpop / n,
sq_rate = x * (stdpop/n)^2) %>%
summarise(total_count = sum(x),
total_pop = sum(n),
dsr = sum(wt_rate) / sum(stdpop) * multiplier,
vardsr = 1/sum(stdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(x)))*(byars_lower(sum(x),conf.level)-sum(x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(x)))*(byars_upper(sum(x),conf.level)-sum(x)) * multiplier) %>%
mutate(method = "Dobson") %>%
select(method, total_count, total_pop, dsr, lowercl, uppercl)
names(phe_dsr) <- c("method", "total_count", "total_pop", "dsr",
paste("lower",conf.level*100,"cl",sep=""),
paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
expect_equal(phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:6],
select(testdata_results,c(2,3,4,5,6)), check.attributes=FALSE, check.names=FALSE)
esp2013 <- c(5000,5500,5500,5500,6000,6000,6500,7000,7000,
7000,7000,6500,6000,5500,5000,4000,2500,1500,1000)
expect_equal(phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:6],
select(testdata_results,c(2,3,4,5,6)), check.attributes=FALSE, check.names=FALSE)
testdata_results       <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",   col_names=TRUE)
expect_equal(phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:6],
select(testdata_results,c(2,3,4,5,6)), check.attributes=FALSE, check.names=FALSE)
select(testdata_results,c(2,3,4,5,6))
phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:6]
phe_dsr <- function(x,n,stdpop = esp2013, groupref = "All", conf.level = 0.95, multiplier = 100000) {
# validate arguments
if (any(x < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(n <= 0)) {
stop("denominators must all be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be >= 90 and <= 100 (or >= 0.9 and <= 1)")
} else if (length(x) != length(n)) {
stop("numerator and denominator vectors must be of equal length")
} else if (length(x) %% length(stdpop) !=0) {
stop("numerator vector length must be a multiple of standard population vector length")
} else if (sum(x) < 10) {
stop("DSR calculation is not valid for total counts < 10")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate DSR and CIs
phe_dsr <- data.frame(x, n, stdpop, groupref) %>%
group_by(groupref) %>%
mutate(wt_rate = x * stdpop / n,
sq_rate = x * (stdpop/n)^2) %>%
summarise(total_count = sum(x),
total_pop = sum(n),
dsr = sum(wt_rate) / sum(stdpop) * multiplier,
vardsr = 1/sum(stdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(x)))*(byars_lower(sum(x),conf.level)-sum(x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(x)))*(byars_upper(sum(x),conf.level)-sum(x)) * multiplier) %>%
mutate(method = "Dobson") %>%
select(method, groupref, total_count, total_pop, dsr, lowercl, uppercl)
names(phe_dsr) <- c("method", "group", "total_count", "total_pop", "dsr",
paste("lower",conf.level*100,"cl",sep=""),
paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)
testdata_results
phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:7]
expect_equal(phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:7],
testdata_results, check.attributes=FALSE, check.names=FALSE)
?expect_equal
?expect_equivalent
esp2013 <- c(5000,5500,5500,5500,6000,6000,6500,7000,7000,
7000,7000,6500,6000,5500,5000,4000,2500,1500,1000)
devtools::use_data(esp2013, PHEstatmethods)
str(mtcars)
devtools::use_data(esp2013, esp2013)
devtools::document()
library(PHEstatmethods)
rm(list=ls())
esp2013
library(testthat)
library(readxl)
testdata_DSR_multiarea <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_multiarea", col_names=TRUE)
testdata_results       <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",   col_names=TRUE)
expect_equal(phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:7]
testdata_results, check.attributes=FALSE, check.names=FALSE)
expect_equal(phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:7],
testdata_results, check.attributes=FALSE, check.names=FALSE)
phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)
testdata_DSR_multiarea$area
phe_dsr <- function(x,n,stdpop = esp2013, groupref = 1, conf.level = 0.95, multiplier = 100000) {
# validate arguments
if (any(x < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(n <= 0)) {
stop("denominators must all be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be >= 90 and <= 100 (or >= 0.9 and <= 1)")
} else if (length(x) != length(n)) {
stop("numerator and denominator vectors must be of equal length")
} else if (length(x) %% length(stdpop) !=0) {
stop("numerator vector length must be a multiple of standard population vector length")
} else if (sum(x) < 10) {
stop("DSR calculation is not valid for total counts < 10")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate DSR and CIs
phe_dsr <- data.frame(x, n, stdpop, groupref) %>%
group_by(groupref) %>%
mutate(wt_rate = x * stdpop / n,
sq_rate = x * (stdpop/n)^2) %>%
summarise(total_count = sum(x),
total_pop = sum(n),
dsr = sum(wt_rate) / sum(stdpop) * multiplier,
vardsr = 1/sum(stdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(x)))*(byars_lower(sum(x),conf.level)-sum(x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(x)))*(byars_upper(sum(x),conf.level)-sum(x)) * multiplier) %>%
mutate(method = "Dobson") %>%
select(method, groupref, total_count, total_pop, dsr, lowercl, uppercl)
names(phe_dsr) <- c("method", "group", "total_count", "total_pop", "dsr",
paste("lower",conf.level*100,"cl",sep=""),
paste("upper",conf.level*100,"cl",sep=""))
return(phe_dsr)
}
phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)
expect_equal(phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:7],
testdata_results, check.attributes=FALSE, check.names=FALSE)
phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:7]
testdata_results
select(testdata_results,1:6)
expect_equal(phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:7],
select(testdata_results,1:6), check.attributes=FALSE, check.names=FALSE)
expect_equal(phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:7],
select(testdata_results,1:6), check.attributes=FALSE, check.names=FALSE)
testdata_DSR_multiarea <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_multiarea", col_names=TRUE)
testdata_results       <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",   col_names=TRUE)
expect_equal(phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:7],
select(testdata_results,1:6), check.attributes=FALSE, check.names=FALSE)
??testthat
testthat
testdata_results$group <- as.factor(testdata_results$group)
View(testdata_results)
expect_equal(phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:7],
select(testdata_results,1:6), check.attributes=FALSE, check.names=FALSE)
View(testdata_results)
phe_dsr(testdata_DSR_multiarea$count, testdata_DSR_multiarea$pop,
groupref=testdata_DSR_multiarea$area, multiplier=10000)[2:7]
select(testdata_results,1:6)
