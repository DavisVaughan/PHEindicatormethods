phe_rate <- data %>%
mutate(rate = !!x/!!n*multiplier,
lowercl = if_else(!!x < 10, qchisq((1-conf.level)/2,2*!!x)/2/!!n*multiplier,
byars_lower(!!x,conf.level)/!!n*multiplier),
uppercl = if_else(!!x < 10, qchisq(conf.level+(1-conf.level)/2,2*!!x+2)/2/!!n*multiplier,
byars_upper(!!x,conf.level)/!!n*multiplier),
confidence = paste(conf.level*100,"%"),
method  = if_else(!!x < 10, "Exact","Byars"))
if (type == "lower") {
phe_rate <- phe_rate %>%
select(-uppercl, -rate, -method, -confidence)
} else if (type == "upper") {
phe_rate <- phe_rate %>%
select(-lowercl, -rate, -method, -confidence)
} else if (type == "rate") {
phe_rate<- phe_rate %>%
select(-lowercl, -uppercl, -method, -confidence)
} else if (type == "combined") {
phe_rate <- phe_rate %>%
select(-method, -confidence)
}
return(phe_rate)
}
phe_rate(test_Rate_100,Numerator, Denominator)
# create function to calculate rate and CIs using Byar's method
phe_rate <- function(data,x, n, type = "combined", conf.level = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)) {
stop("data must contain a data.frame object")
} else if (missing(x)) {
stop("x must contain an unquoted field name from data")
} else if (missing(n)) {
stop("n must contain an unquoted field name from data")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate rate and CIs
phe_rate <- data %>%
mutate(rate = (!!x)/(!!n)*multiplier,
lowercl = if_else((!!x) < 10, qchisq((1-conf.level)/2,2*(!!x))/2/(!!n)*multiplier,
byars_lower((!!x),conf.level)/(!!n)*multiplier),
uppercl = if_else((!!x) < 10, qchisq(conf.level+(1-conf.level)/2,2*!!x+2)/2/(!!n)*multiplier,
byars_upper((!!x),conf.level)/(!!n)*multiplier),
confidence = paste(conf.level*100,"%"),
method  = if_else((!!x) < 10, "Exact","Byars"))
if (type == "lower") {
phe_rate <- phe_rate %>%
select(-uppercl, -rate, -method, -confidence)
} else if (type == "upper") {
phe_rate <- phe_rate %>%
select(-lowercl, -rate, -method, -confidence)
} else if (type == "rate") {
phe_rate<- phe_rate %>%
select(-lowercl, -uppercl, -method, -confidence)
} else if (type == "combined") {
phe_rate <- phe_rate %>%
select(-method, -confidence)
}
return(phe_rate)
}
phe_rate(test_Rate_100,Numerator, Denominator)
# create function to calculate rate and CIs using Byar's method
phe_rate <- function(data,x, n, type = "combined", conf.level = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)) {
stop("data must contain a data.frame object")
} else if (missing(x)) {
stop("x must contain an unquoted field name from data")
} else if (missing(n)) {
stop("n must contain an unquoted field name from data")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate rate and CIs
phe_rate <- data %>%
mutate(rate = (!!x)/(!!n)*multiplier,
lowercl = if_else((!!x) < 10, qchisq((1-conf.level)/2,2*(!!x))/2/(!!n)*multiplier,
byars_lower((!!x),conf.level)/(!!n)*multiplier),
uppercl = if_else((!!x) < 10, qchisq(conf.level+(1-conf.level)/2,2*(!!x)+2)/2/(!!n)*multiplier,
byars_upper((!!x),conf.level)/(!!n)*multiplier),
confidence = paste(conf.level*100,"%"),
method  = if_else((!!x) < 10, "Exact","Byars"))
if (type == "lower") {
phe_rate <- phe_rate %>%
select(-uppercl, -rate, -method, -confidence)
} else if (type == "upper") {
phe_rate <- phe_rate %>%
select(-lowercl, -rate, -method, -confidence)
} else if (type == "rate") {
phe_rate<- phe_rate %>%
select(-lowercl, -uppercl, -method, -confidence)
} else if (type == "combined") {
phe_rate <- phe_rate %>%
select(-method, -confidence)
}
return(phe_rate)
}
phe_rate(test_Rate_100,Numerator, Denominator)
phe_rate(test_Rate_100,Numerator, Denominator, type="full")
checkk <- phe_rate(test_Rate_100,Numerator, Denominator, type="full")
View(checkk)
# create phe_proportion function to execute binom.confint with method fixed to wilson
phe_proportion <- function(data, x, n, type="combined", conf.level=0.95, percentage=FALSE) {
# check required arguments present
if (missing(data)) {
stop("data must contain a data.frame object")
} else if (missing(x)) {
stop("x must contain an unquoted field name from data")
} else if (missing(n)) {
stop("n must contain an unquoted field name from data")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must be greater than zero")
} else if (any(pull(data, !!x) > pull(data, !!n))) {
stop("numerators must be less than or equal to denominator for a proportion statistic")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# set multiplier
multiplier <- 1
if (percentage == TRUE) {
multiplier <- 100
}
# calculate proportion and CIs
phe_proportion <- data %>%
binom.confint((!!x), (!!n), conf.level, methods="wilson") %>%
mutate(mean = mean * multiplier,
lower = lower * multiplier,
upper = upper * multiplier,
confidence = paste(conf.level*100,"%"),
method = "Wilson") %>%
select(-methods)
return(phe_proportion)
}
View(test_Prop_1)
phe_proportion(test_Prop_1,numerator, Denominator)
phe_proportion(test_Prop_1,Numerator, Denominator)
qnorm(0.95+(1-0.95)/2)
(2*65+qnorm(0.95+(1-0.95)/2)^2-qnorm(0.95+(1-0.95)/2)*sqrt(qnorm(0.95+(1-0.95)/2)^2+4*65*(1-(65/100)))/2/(100+qnorm(0.95+(1-0.95)/2)^2)
(2*65+qnorm(0.95+(1-0.95)/2)^2-qnorm(0.95+(1-0.95)/2)*sqrt(qnorm(0.95+(1-0.95)/2)^2+4*65*(1-(65/100))))/2/(100+qnorm(0.95+(1-0.95)/2)^2)
z <- qnorm(conf.level+(1-conf.level)/2)
qnorm(0.95+(1-0.95)/2)
# create function to calculate Byar's lower CI limit
wilson_lower <- function(x, n, conf.level = 0.95) {
# validate arguments
if (any(x < 0)) {
stop("observed cases must all be greater than or equal to zero")
} if (any(n < 0)) {
stop("sample sizes must all be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
}
# set z
z <- qnorm(conf.level+(1-conf.level)/2)
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate
wilson_lower <- (2*x+z^2-z*sqrt(z^2+4*x*(1-(x/n))))/2/(n+z^2)
#                 (2*65+qnorm(0.95+(1-0.95)/2)^2-qnorm(0.95+(1-0.95)/2)*sqrt(qnorm(0.95+(1-0.95)/2)^2+4*65*(1-(65/100))))/2/(100+qnorm(0.95+(1-0.95)/2)^2)
return(wilson_lower)
}
wilson_lower <- function(x, n, conf.level = 0.95) {
# validate arguments
if (any(x < 0)) {
stop("observed cases must all be greater than or equal to zero")
} else if (any(n < 0)) {
stop("sample sizes must all be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
}
# set z
z <- qnorm(conf.level+(1-conf.level)/2)
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate
wilson_lower <- (2*x+z^2-z*sqrt(z^2+4*x*(1-(x/n))))/2/(n+z^2)
#                 (2*65+qnorm(0.95+(1-0.95)/2)^2-qnorm(0.95+(1-0.95)/2)*sqrt(qnorm(0.95+(1-0.95)/2)^2+4*65*(1-(65/100))))/2/(100+qnorm(0.95+(1-0.95)/2)^2)
return(wilson_lower)
}
wilson_lower(65,100)
wilson_lower(65,70)
# create function to calculate Byar's lower CI limit
wilson_upper <- function(x, n, conf.level = 0.95) {
# validate arguments
if (any(x < 0)) {
stop("observed cases must all be greater than or equal to zero")
} else if (any(n < 0)) {
stop("sample sizes must all be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
}
# set z
z <- qnorm(conf.level+(1-conf.level)/2)
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate
wilson_upper <- (2*x+z^2+z*sqrt(z^2+4*x*(1-(x/n))))/2/(n+z^2)
return(wilson_upper)
}
wilson_upper(65,70)
z
# create phe_proportion function to execute binom.confint with method fixed to wilson
phe_proportion <- function(data, x, n, type="combined", conf.level=0.95, percentage=FALSE) {
# check required arguments present
if (missing(data)) {
stop("data must contain a data.frame object")
} else if (missing(x)) {
stop("x must contain an unquoted field name from data")
} else if (missing(n)) {
stop("n must contain an unquoted field name from data")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must be greater than zero")
} else if (any(pull(data, !!x) > pull(data, !!n))) {
stop("numerators must be less than or equal to denominator for a proportion statistic")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# set multiplier
multiplier <- 1
if (percentage == TRUE) {
multiplier <- 100
}
# calculate proportion and CIs
phe_proportion <- data %>%
mutate(proportion = x/n * multiplier,
lowercl = wilson_lower(x,n,conf.level) * multiplier,
uppercl = wilson_upper(x,n,conf.level) * multiplier,
confidence = paste(conf.level*100,"%"),
method = "Wilson")
if (type == "lower") {
phe_rate <- phe_rate %>%
select(-proportion, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_rate <- phe_rate %>%
select(-proportion, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_rate<- phe_rate %>%
select(-lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_rate <- phe_rate %>%
select( -confidence, -method)
}
return(phe_proportion)
}
phe_proportion(test_Prop_1,Numerator, Denominator)
library(rlang)
library(dplyr)
phe_proportion(test_Prop_1,Numerator, Denominator)
qchisq((1-0.95)/2,2*(65))
qchisq(0.95+(1-0.95)/2,2*(65)+2)
# create phe_proportion function to execute binom.confint with method fixed to wilson
phe_proportion <- function(data, x, n, type="combined", conf.level=0.95, percentage=FALSE) {
# check required arguments present
if (missing(data)) {
stop("data must contain a data.frame object")
} else if (missing(x)) {
stop("x must contain an unquoted field name from data")
} else if (missing(n)) {
stop("n must contain an unquoted field name from data")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must be greater than zero")
} else if (any(pull(data, !!x) > pull(data, !!n))) {
stop("numerators must be less than or equal to denominator for a proportion statistic")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# set multiplier
multiplier <- 1
if (percentage == TRUE) {
multiplier <- 100
}
# calculate proportion and CIs
phe_proportion <- data %>%
mutate(proportion = (!!x)/(!!n) * multiplier,
lowercl = wilson_lower((!!x),(!!n),conf.level) * multiplier,
uppercl = wilson_upper((!!x),(!!n),conf.level) * multiplier,
confidence = paste(conf.level*100,"%"),
method = "Wilson")
if (type == "lower") {
phe_rate <- phe_rate %>%
select(-proportion, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_rate <- phe_rate %>%
select(-proportion, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_rate<- phe_rate %>%
select(-lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_rate <- phe_rate %>%
select( -confidence, -method)
}
return(phe_proportion)
}
phe_proportion(test_Prop_1,Numerator, Denominator)
# create phe_proportion function to execute binom.confint with method fixed to wilson
phe_proportion <- function(data, x, n, type="combined", conf.level=0.95, percentage=FALSE) {
# check required arguments present
if (missing(data)) {
stop("data must contain a data.frame object")
} else if (missing(x)) {
stop("x must contain an unquoted field name from data")
} else if (missing(n)) {
stop("n must contain an unquoted field name from data")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must be greater than zero")
} else if (any(pull(data, !!x) > pull(data, !!n))) {
stop("numerators must be less than or equal to denominator for a proportion statistic")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# set multiplier
multiplier <- 1
if (percentage == TRUE) {
multiplier <- 100
}
# calculate proportion and CIs
phe_proportion <- data %>%
mutate(proportion = (!!x)/(!!n) * multiplier,
lowercl = wilson_lower((!!x),(!!n),conf.level) * multiplier,
uppercl = wilson_upper((!!x),(!!n),conf.level) * multiplier,
confidence = paste(conf.level*100,"%"),
method = "Wilson")
if (type == "lower") {
phe_proportion <- phe_rate %>%
select(-proportion, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_proportion <- phe_rate %>%
select(-proportion, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_proportion<- phe_rate %>%
select(-lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_proportion <- phe_rate %>%
select( -confidence, -method)
}
return(phe_proportion)
}
phe_proportion(test_Prop_1,Numerator, Denominator)
# create phe_proportion function to execute binom.confint with method fixed to wilson
phe_proportion <- function(data, x, n, type="combined", conf.level=0.95, percentage=FALSE) {
# check required arguments present
if (missing(data)) {
stop("data must contain a data.frame object")
} else if (missing(x)) {
stop("x must contain an unquoted field name from data")
} else if (missing(n)) {
stop("n must contain an unquoted field name from data")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must be greater than zero")
} else if (any(pull(data, !!x) > pull(data, !!n))) {
stop("numerators must be less than or equal to denominator for a proportion statistic")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# set multiplier
multiplier <- 1
if (percentage == TRUE) {
multiplier <- 100
}
# calculate proportion and CIs
phe_proportion <- data %>%
mutate(proportion = (!!x)/(!!n) * multiplier,
lowercl = wilson_lower((!!x),(!!n),conf.level) * multiplier,
uppercl = wilson_upper((!!x),(!!n),conf.level) * multiplier,
confidence = paste(conf.level*100,"%"),
method = "Wilson")
if (type == "lower") {
phe_proportion <- phe_proportion %>%
select(-proportion, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_proportion <- phe_proportion %>%
select(-proportion, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_proportion<- phe_proportion %>%
select(-lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_proportion <- phe_proportion %>%
select( -confidence, -method)
}
return(phe_proportion)
}
phe_proportion(test_Prop_1,Numerator, Denominator)
phe_proportion(test_Prop_100, Numerator, Denominator,
percentage=TRUE)
phe_proportion(test_Prop_100, Numerator, Denominator,
percentage=TRUE, type="full")
phe_proportion(test_Prop_100, Numerator, Denominator,
percentage=TRUE, type="full")[1,10:14]
phe_proportion(test_Prop_100, Numerator, Denominator,
percentage=TRUE, type="full")[[1,10:14]]
phe_proportion(test_Prop_100, Numerator, Denominator,
percentage=TRUE, type="full")[10:14]
View(test_Prop_1)
library(testthat)
expect_equal(phe_proportion(test_Prop_100, Numerator, Denominator,
percentage=TRUE, type="full")[12:14],
select(test_Prop_100,c(5,6,7)),check.attributes=FALSE, check.names=FALSE, info="test 1")
View(test_DSR_err3)
View(test_DSR_results)
View(test_DSR_multiarea)
data.frame(indicatorid = rep(c(1234, 5678, 91011, 121314), each = 19 * 2 * 5),
year = rep(2006:2010, each = 19 * 2),
sex = rep(rep(c("Male", "Female"), each = 19), 5),
obs = sample(200, 19 * 2 * 5 * 4, replace = TRUE),
pop = sample(10000:20000, 19 * 2 * 5 * 4, replace = TRUE))
data.frame(area = rep(c("Area1","Area2","Area3","Area4"), each = 2),
year = rep(2015:2016, each = 4 * 2)
)
data.frame(area = rep(c("Area1","Area2","Area3","Area4"), each = 2*4),
year = rep(2015:2016, each = 4 * 2))
data.frame(area = rep(c("Area1","Area2","Area3","Area4"), 2),
year = rep(2015:2016, each = 4 * 2))
data.frame(area = rep(c("Area1","Area2","Area3","Area4"), 2),
year = rep(2015:2016, each = 4))
data.frame(area = rep(c("Area1","Area2","Area3","Area4"), 2),
year = rep(2015:2016, each = 4),
obs = sample(200, 2 * 4, replace = TRUE),
pop = sample(10000:20000, 2 * 4, replace = TRUE))
