# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%"),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$confidence[phe_dsr$total_count < 10] <- "NA - total count is < 10"
phe_dsr$method[phe_dsr$total_count < 10]     <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
#good code
phe_dsr(test_DSR_multiarea,count,pop,stdpop=esp2013)
phe_dsr(test_DSR_1976,count,pop,stdpop=esp2013[1:18])
phe_dsr(test_DSR_1976,count,pop,stdpop=test_DSR_1976$stdpop)
phe_dsr(test_DSR_1976,count,pop,stdpop)
test <- test_DSR_1976 %>%
+ mutate(esp1976 = stdpop) %>%
+ select(-stdpop)
phe_dsr(test,count,pop,esp1976)
#bad code
phe_dsr(test_DSR_multiarea,count,pop,esp2013[18])
phe_dsr(test_DSR_multiarea,count,pop,test_DSR_1976$stdpop)
phe_dsr(slice(test_DSR_multiarea,54),count,pop,esp2013)
debug(phe_dsr)
phe_dsr(slice(test_DSR_multiarea,54),count,pop,esp2013)
n_distinct(select(summarise(data, n = n()), n))
summarise(data, n = n())
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "combined", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
} else if (n_distinct(select(summarise(data,n=n()),n)) != 1) {
stop("data must contain the same number of rows for each group")
#  } else if (is.numeric(stdpop)) {
}  else if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%"),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$confidence[phe_dsr$total_count < 10] <- "NA - total count is < 10"
phe_dsr$method[phe_dsr$total_count < 10]     <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
phe_dsr(test,count,pop,esp1976)
debug(phe_dsr)
phe_dsr(test,count,pop,esp1976)
n_distinct(select(summarise(data, n = n()), n))
summarise(data, n = n())
select(summarise(data, n = n()), n)
slice(select(summarise(data, n = n()), n), 1)
pull(slice(select(summarise(data, n = n()), n), 1))
length(stdpop)
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "combined", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
} else if (n_distinct(select(summarise(data,n=n()),n)) != 1) {
stop("data must contain the same number of rows for each group")
#  } else if (is.numeric(stdpop)) {
}  else if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%"),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$confidence[phe_dsr$total_count < 10] <- "NA - total count is < 10"
phe_dsr$method[phe_dsr$total_count < 10]     <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
?is.vector
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "combined", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
} else if (n_distinct(select(summarise(data,n=n()),n)) != 1) {
stop("data must contain the same number of rows for each group")
} else if (is.vector(stdpop)) {   #when column named passed stdpop not found here for is.numeric(stdpop or for length(stdpop))
if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%"),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$confidence[phe_dsr$total_count < 10] <- "NA - total count is < 10"
phe_dsr$method[phe_dsr$total_count < 10]     <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
phe_dsr(test,count,pop,esp1976)
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "combined", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
} else if (n_distinct(select(summarise(data,n=n()),n)) != 1) {
stop("data must contain the same number of rows for each group")
} else if (exists(stdpop)) {   #when column named passed stdpop not found here for is.numeric(stdpop or for length(stdpop))
if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%"),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$confidence[phe_dsr$total_count < 10] <- "NA - total count is < 10"
phe_dsr$method[phe_dsr$total_count < 10]     <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
phe_dsr(test,count,pop,esp1976)
exists(esp2013)
exists(df)
exists("df")
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "combined", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
} else if (n_distinct(select(summarise(data,n=n()),n)) != 1) {
stop("data must contain the same number of rows for each group")
} else if (exists(enquostdpop)) {   #when column named passed stdpop not found here for is.numeric(stdpop or for length(stdpop))
if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%"),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$confidence[phe_dsr$total_count < 10] <- "NA - total count is < 10"
phe_dsr$method[phe_dsr$total_count < 10]     <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
phe_dsr(test,count,pop,esp1976)
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "combined", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
} else if (n_distinct(select(summarise(data,n=n()),n)) != 1) {
stop("data must contain the same number of rows for each group")
} else if (exists((!!enquostdpop))) {   #when column named passed stdpop not found here for is.numeric(stdpop or for length(stdpop))
if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%"),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$confidence[phe_dsr$total_count < 10] <- "NA - total count is < 10"
phe_dsr$method[phe_dsr$total_count < 10]     <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
phe_dsr(test,count,pop,esp1976)
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "combined", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
} else if (n_distinct(select(summarise(data,n=n()),n)) != 1) {
stop("data must contain the same number of rows for each group")
} else if (exists((!enquostdpop))) {   #when column named passed stdpop not found here for is.numeric(stdpop or for length(stdpop))
if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%"),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$confidence[phe_dsr$total_count < 10] <- "NA - total count is < 10"
phe_dsr$method[phe_dsr$total_count < 10]     <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
phe_dsr(test,count,pop,esp1976)
names(test)
