phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
phe_dsr(test_DSR_1976, count, pop, stdpop = esp1976, stdpoptype="field")
# define the DSR function using Dobson method
phe_dsr <- function(data, x, n, stdpop = esp2013, stdpoptype = "vector", type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)) {
stop("function phe_dsr requires at least 3 arguments: data, x, n")
}
if (stdpoptype == "vector") {
if(pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
data <- bind_cols(data,stdpop_calc = rep(stdpop,times=nrow(summarise(data,n=n()))))
} else if (stdpoptype == "field") {
enquostdpop <- enquo(stdpop)
if (!((!!enquostdpop) %in% colnames(data))) {
stop("stdpop field name specified does not exist")
}
data <- mutate(data,stdpop_calc = !!enquostdpop)
} else {
stop("valid values for stdpoptype are vector and field")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(ungroup(summarise(data,n=n())),n)) != 1) {
stop("data must contain the same number of rows for each group")
#  } else if (!exists("stdpop", where=data)) {
#      if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
#        stop("stdpop length must equal number of rows in each group within data")
#    }
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * stdpop_calc / (!!n),
sq_rate = (!!x) * (stdpop_calc/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
value = sum(wt_rate) / sum(stdpop_calc) * multiplier,
vardsr = 1/sum(stdpop_calc)^2 * sum(sq_rate),
lowercl = value + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = value + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%",sep=""),
statistic = paste("dsr per",format(multiplier,scientific=F)),
method = "Dobson")
phe_dsr$value[phe_dsr$total_count < 10]    <- NA #"NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]  <- NA #"NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]  <- NA #"NA - total count is < 10"
phe_dsr$statistic[phe_dsr$total_count <10] <- "dsr NA for total count < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
phe_dsr(test_DSR_1976, count, pop, stdpop = esp1976, stdpoptype="field")
debug(phe_dsr)
phe_dsr(test_DSR_1976, count, pop, stdpop = esp1976, stdpoptype="field")
stdpop
enquostdpop
"stdpop"
((!!enquostdpop) %in% colnames(data))
"esp1976" %in% colnames(test_DSR_1976)
sapply(test_DSR_1976,deparse)
sapply(stdpop,deparse)
debug(phe_dsr)
phe_dsr(test_DSR_1976, count, pop, stdpop = esp1976, stdpoptype="field")
sapply(stdpop,deparse)
sapply(enquostdpop,deparse)
function(...) sapply(substitute({ ... })[-1], deparse)
as.character(stdpop)
?try
try(mutate(test_DSR_1976,stdpop_calc = esp1976))
try(mutate(test_DSR_1976,stdpop_calc = esp19))
test_DSR_1976
library(rlan)
library(dplyr)
library(rlang)
rename(test_DSR_1976,stdpop_calc = esp1976)
try(rename(test_DSR_1976,stdpop_calc = esp1976))
try(rename(test_DSR_1976,stdpop_calc = esp1976)) ==  TRUE
try(rename(test_DSR_1976,stdpop_calc = esp1976)) ==  FALSE
?try
tryCatch(rename(test_DSR_1976,stdpop_calc = esp1976))
tryCatch(rename(test_DSR_1976,stdpop_calc = esp1976),error = "ERR")
tryCatch(rename(test_DSR_1976,stdpop_calc = esp197),error = "ERR")
ERR
try(test_DSR_1976$esp1976[1])
try(test_DSR_1976$esp196[1])
# define the DSR function using Dobson method
phe_dsr <- function(data, x, n, stdpop = esp2013, stdpoptype = "vector", type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)) {
stop("function phe_dsr requires at least 3 arguments: data, x, n")
}
if (stdpoptype == "vector") {
if (pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
data <- bind_cols(data,stdpop_calc = rep(stdpop,times=nrow(summarise(data,n=n()))))
} else if (stdpoptype == "field") {
enquostdpop <- enquo(stdpop)
if (try(data$stdpop[1]) == is.null) {
data <- mutate(data,stdpop_calc = !!enquostdpop)
} else stop("stdpop is not a field name from data")
} else {
stop("valid values for stdpoptype are vector and field")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(ungroup(summarise(data,n=n())),n)) != 1) {
stop("data must contain the same number of rows for each group")
#  } else if (!exists("stdpop", where=data)) {
#      if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
#        stop("stdpop length must equal number of rows in each group within data")
#    }
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * stdpop_calc / (!!n),
sq_rate = (!!x) * (stdpop_calc/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
value = sum(wt_rate) / sum(stdpop_calc) * multiplier,
vardsr = 1/sum(stdpop_calc)^2 * sum(sq_rate),
lowercl = value + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = value + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%",sep=""),
statistic = paste("dsr per",format(multiplier,scientific=F)),
method = "Dobson")
phe_dsr$value[phe_dsr$total_count < 10]    <- NA #"NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]  <- NA #"NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]  <- NA #"NA - total count is < 10"
phe_dsr$statistic[phe_dsr$total_count <10] <- "dsr NA for total count < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
phe_dsr(test_DSR_1976, count, pop, stdpop = esp1976, stdpoptype="field")
# define the DSR function using Dobson method
phe_dsr <- function(data, x, n, stdpop = esp2013, stdpoptype = "vector", type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)) {
stop("function phe_dsr requires at least 3 arguments: data, x, n")
}
if (stdpoptype == "vector") {
if (pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
data <- bind_cols(data,stdpop_calc = rep(stdpop,times=nrow(summarise(data,n=n()))))
} else if (stdpoptype == "field") {
enquostdpop <- enquo(stdpop)
if (exists(data$enquostdpop)) {
data <- mutate(data,stdpop_calc = !!enquostdpop)
} else stop("stdpop is not a field name from data")
} else {
stop("valid values for stdpoptype are vector and field")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(ungroup(summarise(data,n=n())),n)) != 1) {
stop("data must contain the same number of rows for each group")
#  } else if (!exists("stdpop", where=data)) {
#      if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
#        stop("stdpop length must equal number of rows in each group within data")
#    }
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * stdpop_calc / (!!n),
sq_rate = (!!x) * (stdpop_calc/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
value = sum(wt_rate) / sum(stdpop_calc) * multiplier,
vardsr = 1/sum(stdpop_calc)^2 * sum(sq_rate),
lowercl = value + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = value + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%",sep=""),
statistic = paste("dsr per",format(multiplier,scientific=F)),
method = "Dobson")
phe_dsr$value[phe_dsr$total_count < 10]    <- NA #"NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]  <- NA #"NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]  <- NA #"NA - total count is < 10"
phe_dsr$statistic[phe_dsr$total_count <10] <- "dsr NA for total count < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
phe_dsr(test_DSR_1976, count, pop, stdpop = esp1976, stdpoptype="field")
# define the DSR function using Dobson method
phe_dsr <- function(data, x, n, stdpop = esp2013, stdpoptype = "vector", type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)) {
stop("function phe_dsr requires at least 3 arguments: data, x, n")
}
if (stdpoptype == "vector") {
if (pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
data <- bind_cols(data,stdpop_calc = rep(stdpop,times=nrow(summarise(data,n=n()))))
} else if (stdpoptype == "field") {
enquostdpop <- enquo(stdpop)
if (exists(data$stdpop)) {
data <- mutate(data,stdpop_calc = !!enquostdpop)
} else stop("stdpop is not a field name from data")
} else {
stop("valid values for stdpoptype are vector and field")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(ungroup(summarise(data,n=n())),n)) != 1) {
stop("data must contain the same number of rows for each group")
#  } else if (!exists("stdpop", where=data)) {
#      if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
#        stop("stdpop length must equal number of rows in each group within data")
#    }
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * stdpop_calc / (!!n),
sq_rate = (!!x) * (stdpop_calc/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
value = sum(wt_rate) / sum(stdpop_calc) * multiplier,
vardsr = 1/sum(stdpop_calc)^2 * sum(sq_rate),
lowercl = value + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = value + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%",sep=""),
statistic = paste("dsr per",format(multiplier,scientific=F)),
method = "Dobson")
phe_dsr$value[phe_dsr$total_count < 10]    <- NA #"NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]  <- NA #"NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]  <- NA #"NA - total count is < 10"
phe_dsr$statistic[phe_dsr$total_count <10] <- "dsr NA for total count < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
phe_dsr(test_DSR_1976, count, pop, stdpop = esp1976, stdpoptype="field")
?is.null
# define the DSR function using Dobson method
phe_dsr <- function(data, x, n, stdpop = esp2013, stdpoptype = "vector", type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)) {
stop("function phe_dsr requires at least 3 arguments: data, x, n")
}
if (stdpoptype == "vector") {
if (pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
data <- bind_cols(data,stdpop_calc = rep(stdpop,times=nrow(summarise(data,n=n()))))
} else if (stdpoptype == "field") {
enquostdpop <- enquo(stdpop)
if (is.null(try(data$stdpop))) {
stop("stdpop is not a field name from data")
} else data <- mutate(data,stdpop_calc = !!enquostdpop)
#            if (exists(data$stdpop)) {
} else {
stop("valid values for stdpoptype are vector and field")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(ungroup(summarise(data,n=n())),n)) != 1) {
stop("data must contain the same number of rows for each group")
#  } else if (!exists("stdpop", where=data)) {
#      if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
#        stop("stdpop length must equal number of rows in each group within data")
#    }
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * stdpop_calc / (!!n),
sq_rate = (!!x) * (stdpop_calc/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
value = sum(wt_rate) / sum(stdpop_calc) * multiplier,
vardsr = 1/sum(stdpop_calc)^2 * sum(sq_rate),
lowercl = value + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = value + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%",sep=""),
statistic = paste("dsr per",format(multiplier,scientific=F)),
method = "Dobson")
phe_dsr$value[phe_dsr$total_count < 10]    <- NA #"NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]  <- NA #"NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]  <- NA #"NA - total count is < 10"
phe_dsr$statistic[phe_dsr$total_count <10] <- "dsr NA for total count < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
phe_dsr(test_DSR_1976, count, pop, stdpop = esp1976, stdpoptype="field")
try(select(test_DSR_1976,esp1976))
try(select(test_DSR_1976,esp197))
tryCatch(select(test_DSR_1976,esp197))
tryCatch(select(test_DSR_1976,esp1976))
?tryNe
?try
tryCatch(select(test_DSR_1976,esp1976),silent=TRUE)
tryCatch(select(test_DSR_1976,esp196),silent=TRUE)
colnames(test_DSR_1976)
# define the DSR function using Dobson method
phe_dsr <- function(data, x, n, stdpop = esp2013, stdpoptype = "vector", type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)) {
stop("function phe_dsr requires at least 3 arguments: data, x, n")
}
if (stdpoptype == "vector") {
if (pull(slice(select(ungroup(summarise(data,n=n())),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
data <- bind_cols(data,stdpop_calc = rep(stdpop,times=nrow(summarise(data,n=n()))))
} else if (stdpoptype == "field") {
enquostdpop <- enquo(stdpop)
# if (is.null(try(select(data,(!!enquostdpop))))) {
if (stdpop %in% colnames(data)) {
data <- mutate(data,stdpop_calc = !!enquostdpop)
} else stop("stdpop is not a field name from data")
#            if (exists(data$stdpop)) {
} else {
stop("valid values for stdpoptype are vector and field")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(ungroup(summarise(data,n=n())),n)) != 1) {
stop("data must contain the same number of rows for each group")
#  } else if (!exists("stdpop", where=data)) {
#      if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
#        stop("stdpop length must equal number of rows in each group within data")
#    }
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * stdpop_calc / (!!n),
sq_rate = (!!x) * (stdpop_calc/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
value = sum(wt_rate) / sum(stdpop_calc) * multiplier,
vardsr = 1/sum(stdpop_calc)^2 * sum(sq_rate),
lowercl = value + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = value + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%",sep=""),
statistic = paste("dsr per",format(multiplier,scientific=F)),
method = "Dobson")
phe_dsr$value[phe_dsr$total_count < 10]    <- NA #"NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]  <- NA #"NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]  <- NA #"NA - total count is < 10"
phe_dsr$statistic[phe_dsr$total_count <10] <- "dsr NA for total count < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -value, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
phe_dsr(test_DSR_1976, count, pop, stdpop = esp1976, stdpoptype="field")
