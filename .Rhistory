select( -confidence, -method)
}
return(phe_proportion)
}
phe_proportion(c(numerator = c(65,82,100), denominator = c(100,100,100), numerator, denominator)
phe_proportion(numerator = c(65,82,100), denominator = c(100,100,100), numerator, denominator)
phe_proportion(data.frame(numerator = c(65,82,100), denominator = c(100,100,100)), numerator, denominator)
df <- data.frame(area = c("Area1","Area2","Area3"), numerator = c(65,82,100), denominator = c(100,100,100))
df
phe_proportion(df, numerator, denominator)
# -------------------------------------------------------------------------------------------------
#' Wilson
#'
#' Calculates lower confidence limit for a proportion using Wilson's method.
#'
#' @param x the observed number of cases in the sample meeting the required condition; numeric vector; no default
#' @param n the number of cases in the sample; numeric vector; no default
#' @param confidence the required level of confidence expressed as a number between 0.9 and 1
#'                   or 90 and 100; numeric; default 0.95
#'
#' @return Returns a lower confidence limit for an observed number of events usign Wilson's method
#'
#' @examples
#' wilson_lower(65)
#' wilson_lower(65,99.8)
#'
#' @export
#'
#' @family phe statistical functions
#' @seealso \code{\link{phe_proportion}} for proportions,
#'          \code{\link{phe_rate}} for rates,
#'          \code{\link{phe_mean}} for means,
#'          \code{\link{phe_dsr}} for directly standardised rates,
#'          \code{\link{phe_isr}} for indirectly standardised ratios/rates and standardised mortality ratios
# -------------------------------------------------------------------------------------------------
# create function to calculate Byar's lower CI limit
wilson_lower <- function(x, n, confidence = 0.95) {
# validate arguments
if (any(x < 0)) {
stop("observed cases must all be greater than or equal to zero")
} else if (any(n < 0)) {
stop("sample sizes must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# set z
z <- qnorm(confidence+(1-confidence)/2)
# calculate
wilson_lower <- (2*x+z^2-z*sqrt(z^2+4*x*(1-(x/n))))/2/(n+z^2)
return(wilson_lower)
}
# -------------------------------------------------------------------------------------------------
#' Wilson
#'
#' Calculates upper confidence limit for a proportion using Wilson's method.
#'
#' @param x the observed number of cases in the sample meeting the required condition; numeric vector; no default
#' @param n the number of cases in the sample; numeric vector; no default
#' @param confidence the required level of confidence expressed as a number between 0.9 and 1
#'                   or 90 and 100; numeric; default 0.95
#'
#' @return Returns a upper confidence limit for a proportion using Wilson's method
#'
#' @examples
#' wilson_upper(65)
#' wilson_upper(65,99.8)
#'
#' @export
#'
#' @family phe statistical functions
#' @seealso \code{\link{phe_proportion}} for proportions,
#'          \code{\link{phe_rate}} for rates,
#'          \code{\link{phe_mean}} for means,
#'          \code{\link{phe_dsr}} for directly standardised rates,
#'          \code{\link{phe_isr}} for indirectly standardised ratios/rates and standardised mortality ratios
# -------------------------------------------------------------------------------------------------
# create function to calculate Byar's lower CI limit
wilson_upper <- function(x, n, confidence = 0.95) {
# validate arguments
if (any(x < 0)) {
stop("observed cases must all be greater than or equal to zero")
} else if (any(n < 0)) {
stop("sample sizes must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# set z
z <- qnorm(confidence+(1-confidence)/2)
# calculate
wilson_upper <- (2*x+z^2+z*sqrt(z^2+4*x*(1-(x/n))))/2/(n+z^2)
return(wilson_upper)
}
wilson_lower(65)
wilson_lower(65,100)
wilson_lower(65,100,99.8)
df <- data.frame(area = rep(c("Area1","Area2","Area3","Area4"), 2),
year = rep(2015:2016, each = 4),
obs = sample(100, 2 * 4, replace = TRUE),
pop = sample(100:200, 2 * 4, replace = TRUE))
df
phe_rate(df, obs, pop)
df
head(df)
str(df)
test_Rate_100000 <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx", sheet="testdata_Rate_100000", col_names=TRUE)
test_Rate_100    <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx", sheet="testdata_Rate_100",    col_names=TRUE)
View(test_Rate_100)
phe_rate(test_Rate_100,Numerator,Denominator)
test_Rate_100
# create function to calculate rate and CIs using Byar's method
phe_rate <- function(data,x, n, type = "combined", conf.level = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)) {
stop("function phe_dsr requires at least 3 arguments: data, x, n")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate rate and CIs
phe_rate <- data %>%
mutate(rate = (!!x)/(!!n)*multiplier,
lowercl = if_else((!!x) < 10, qchisq((1-conf.level)/2,2*(!!x))/2/(!!n)*multiplier,
byars_lower((!!x),conf.level)/(!!n)*multiplier),
uppercl = if_else((!!x) < 10, qchisq(conf.level+(1-conf.level)/2,2*(!!x)+2)/2/(!!n)*multiplier,
byars_upper((!!x),conf.level)/(!!n)*multiplier),
confidence = paste(conf.level*100,"%"),
method  = if_else((!!x) < 10, "Exact","Byars"))
if (type == "lower") {
phe_rate <- phe_rate %>%
select(-rate, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_rate <- phe_rate %>%
select(-rate, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_rate<- phe_rate %>%
select(-lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_rate <- phe_rate %>%
select( -confidence, -method)
}
return(phe_rate)
}
df <- data.frame(area = rep(c("Area1","Area2","Area3","Area4"), 2),
year = rep(2015:2016, each = 4),
obs = sample(100, 2 * 4, replace = TRUE),
pop = sample(100:200, 2 * 4, replace = TRUE))
df
phe_rate(df,obs,pop)
phe_rate(df,obs,pop, type="full")
devtools::document()
phe_rate(test_Rate_100,Numerator,Denominator)
library(PHEstatmethods)
phe_rate(test_Rate_100,Numerator,Denominator)
library(rlang)
phe_rate(test_Rate_100,Numerator,Denominator)
library(dplyr)
library(tidyr)
library(readxl)
library(testthat)
phe_rate(test_Rate_100,Numerator,Denominator)
phe_dsr(test_DSR_multiarea, count, pop,
type="full", stdpop = esp2013, multiplier=10000)
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "combined", conf.level = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
stdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
} else if (n_distinct(summarise(pull(data),n=n())[,2] != 1)) {            # not working
stop("data must contain the same number of rows for each group")
} else if (summarise(pull(data),n=n())[1,2] != length(stdpop)) {          # not working
stop("stdpop length must equal number of rows in each group within data")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!stdpop) / (!!n),
sq_rate = (!!x) * ((!!stdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!stdpop)) * multiplier,
vardsr = 1/sum(!!stdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),conf.level)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),conf.level)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(conf.level*100,"%"),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10] <- NA
phe_dsr$uppercl[phe_dsr$total_count < 10] <- NA
phe_dsr$lowercl[phe_dsr$total_count < 10] <- NA
phe_dsr$confidence[phe_dsr$total_count < 10] <- NA
phe_dsr$method[phe_dsr$total_count < 10] <- NA
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
phe_dsr(test_DSR_multiarea, count, pop,esp2013)
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "combined", conf.level = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
stdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((conf.level<0.9)|(conf.level >1 & conf.level <90)|(conf.level > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "combined", "full"))) {
stop("type must be one of value, lower, upper, combined or full")
#  } else if (n_distinct(summarise(pull(data),n=n())[,2] != 1)) {            # not working
#    stop("data must contain the same number of rows for each group")
#  } else if (summarise(pull(data),n=n())[1,2] != length(stdpop)) {          # not working
#    stop("stdpop length must equal number of rows in each group within data")
}
# scale confidence level
if (conf.level >= 90) {
conf.level <- conf.level/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!stdpop) / (!!n),
sq_rate = (!!x) * ((!!stdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!stdpop)) * multiplier,
vardsr = 1/sum(!!stdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),conf.level)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),conf.level)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(conf.level*100,"%"),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10] <- NA
phe_dsr$uppercl[phe_dsr$total_count < 10] <- NA
phe_dsr$lowercl[phe_dsr$total_count < 10] <- NA
phe_dsr$confidence[phe_dsr$total_count < 10] <- NA
phe_dsr$method[phe_dsr$total_count < 10] <- NA
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -method)
} else if (type == "combined") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -method)
}
return(phe_dsr)
}
phe_dsr(test_DSR_multiarea, count, pop,
type="full", stdpop = esp2013, multiplier=10000)
# Execute DSR Function:
phe_dsr(test_DSR_multiarea, count, pop, esp2013)
phe_dsr(test_DSR_1976, count, pop, type="full", stdpop = test_DSR_1976$stdpop, multiplier=10000)
phe_dsr(test_DSR_multiarea, count, pop, type="full", stdpop = esp2013, multiplier=1000, conf.level = 99.8)
View(test_Rate_100)
test_Rate_100_input <- test_Rate_100[1:4]
test_Rate_100_input
phe_rate(test_Rate_100_input,Numerator,Denominator)
phe_rate(test_Rate_100_input,Numerator,Denominator, type = "full", conf.level=0.98, multiplier = 10000)
prop <- data.frame(area = c("Area1","Area2","Area3"), numerator = c(65,82,100), denominator = c(100,100,100))
prop
phe_proportion(prop, numerator, denominator)
phe_dsr(test_DSR_1976, count, pop, type="full", stdpop = test_DSR_1976$stdpop, multiplier=10000)
expect_equal(phe_proportion(test_Prop_100, Numerator, Denominator,
percentage=TRUE, type="full")[12:14],
select(test_Prop_100,c(5,6,7)),check.attributes=FALSE, check.names=FALSE, info="test 1")
test_Prop_1   <- read_excel(".\\tests\\testthat\\testdata_Proportion.xlsx", sheet="testdata_Prop_1",   col_names=TRUE)
test_Prop_100 <- read_excel(".\\tests\\testthat\\testdata_Proportion.xlsx", sheet="testdata_Prop_100", col_names=TRUE)
test_Prop_1$Area   <- as.factor(test_Prop_1$Area)
test_Prop_100$Area <- as.factor(test_Prop_100$Area)
expect_equal(phe_proportion(test_Prop_100, Numerator, Denominator,
percentage=TRUE, type="full")[12:14],
select(test_Prop_100,c(5,6,7)),check.attributes=FALSE, check.names=FALSE, info="test 1")
phe_proportion(test_Prop_100, Numerator, Denominator,
percentage=TRUE, type="full")
phe_proportion(test_Prop_100[1:3], Numerator, Denominator,
percentage=TRUE, type="full")
select(test_Prop_100)
test_Prop_100
select(test_Prop_100,1:3,5:7)
phe_proportion(test_Prop_100[1:3], Numerator, Denominator,
percentage=TRUE, type="full")[1:6]
select(test_Prop_100,1:3,5:7)
expect_equal(phe_proportion(test_Prop_100[1:3], Numerator, Denominator,
percentage=TRUE, type="full")[1:6],
select(test_Prop_100,1:3,5:7),check.attributes=FALSE, check.names=FALSE, info="test 1")
View(test_DSR_multiarea)
Y2015 <- test_DSR_multiarea %>%
mutate(Yr=2015)
Y2016 <- test_DSR_multiarea %>%
mutate(Yr=2016,
pop = pop+100)
Y2015 <- test_DSR_multiarea %>%
mutate(Yr=2015)
Y2016 <- test_DSR_multiarea %>%
mutate(Yr=2016,
count + 10)
MultiGroups <- bind_rows(Y2015,Y2016)
MultiGroups
View(MultiGroups)
Y2016 <- test_DSR_multiarea %>%
mutate(Yr=2016,
count = count + 10)
MultiGroups <- bind_rows(Y2015,Y2016)
View(MultiGroups)
phe_dsr(MultiGroups, count, pop, esp2013)
MultiGroups %>%
Group_By(Period)
MultiGroups %>%
group_by(Period)
MultiGroups %>%
group_by(Yr)
phe_dsr(test_DSR_multiarea, count, pop, esp2013)
phe_dsr(MultiGroups, count, pop, esp2013)
MultiGroups2 <- MultiGroups %>%
group_by(Yr)
phe_dsr(MultiGroups2, count, pop, esp2013)
MultiGroups2 <- MultiGroups %>%
group_by(area, Yr)
phe_dsr(MultiGroups2, count, pop, esp2013)
expect_equal(phe_proportion(test_Prop_100[1:3], Numerator, Denominator,
percentage=FALSE, type="full")[1:6],
select(test_Prop_1,1:3,5:7),check.attributes=FALSE, check.names=FALSE, info="test 2")
expect_equal(phe_proportion(test_Prop_100[1:3], Numerator, Denominator,
conf.level=99.8, type="full")[1:6],
select(test_Prop_100,1:3,5,8:9),check.attributes=FALSE, check.names=FALSE, info="test 3")
expect_equal(phe_proportion(test_Prop_1[1:3], Numerator, Denominator,
percentage=FALSE, type="full")[1:6],
select(test_Prop_1,1:3,5:7),check.attributes=FALSE, check.names=FALSE, info="test 2")
expect_equal(phe_proportion(test_Prop_100[1:3], Numerator, Denominator,
percentage=FALSE, type="full")[1:6],
select(test_Prop_1,1:3,5:7),check.attributes=FALSE, check.names=FALSE, info="test 2")
phe_proportion(test_Prop_100[1:3], Numerator, Denominator,
percentage=TRUE, type="full")
select(test_Prop_100,1:3,5:7)
test_Prop_1   <- read_excel(".\\tests\\testthat\\testdata_Proportion.xlsx", sheet="testdata_Prop_1",   col_names=TRUE)
test_Prop_100 <- read_excel(".\\tests\\testthat\\testdata_Proportion.xlsx", sheet="testdata_Prop_100", col_names=TRUE)
test_Prop_1$Area   <- as.factor(test_Prop_1$Area)
test_Prop_100$Area <- as.factor(test_Prop_100$Area)
expect_equal(phe_proportion(test_Prop_100[1:3], Numerator, Denominator,
percentage=TRUE, type="full")[1:6],
select(test_Prop_100,1:3,5:7),check.attributes=FALSE, check.names=FALSE, info="test 1")
expect_equal(data.frame(phe_dsr(test_DSR_multiarea, count, pop,
type="full", stdpop = esp2013, multiplier=10000)[1:6]),
select(filter(test_DSR_results,group!="testdata_1976"),1:6),
check.attributes=FALSE, check.names=FALSE,info="test1")
expect_equal(phe_proportion(test_Prop_100[1:3], Numerator, Denominator,
percentage=TRUE, type="full")[1:6],
select(test_Prop_100,1:3,5:6),check.attributes=FALSE, check.names=FALSE, info="test 1")
?expect_equal
?all.equal
?all.equal
?all.identical
?identical
?all.equal
test_DSR_multiarea <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testdata_multiarea", col_names=TRUE) %>%
group_by(area)
View(test_DSR_multiarea)
test_DSR_results   <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",        col_names=TRUE)
View(test_DSR_results)
View(test_DSR_results)
phe_dsr(test_DSR_multiarea, count, pop,
type="full", stdpop = esp2013, multiplier=10000)
slice(test_DSR_results,1:4)
expect_equal(data.frame(phe_dsr(test_DSR_multiarea, count, pop,
type="full", stdpop = esp2013, multiplier=10000)[1:6]),
slice(test_DSR_results,1:4),
check.attributes=FALSE, check.names=FALSE,info="test1")
expect_equal(data.frame(phe_dsr(test_DSR_multiarea, count, pop,
type="full", stdpop = esp2013, multiplier=10000)[1:6]),
select(filter(test_DSR_results,group!="testdata_1976"),1:6),
check.attributes=FALSE, check.names=FALSE,info="test1")
expect_equal(data.frame(phe_dsr(test_DSR_multiarea, count, pop,
type="full", stdpop = esp2013, multiplier=10000)[1:6]),
select(filter(test_DSR_results,area!="testdata_1976"),1:6),
check.attributes=FALSE, check.names=FALSE,info="test1")
phe_dsr(test_DSR_multiarea, count, pop,
type="full", stdpop = esp2013, multiplier=10000)
phe_dsr(test_DSR_multiarea, count, pop,
type="full", stdpop = esp2013, multiplier=10000)
slice(test_DSR_results,1:4)
expect_equal(data.frame(phe_dsr(test_DSR_multiarea, count, pop,
type="full", stdpop = esp2013, multiplier=10000)),
slice(test_DSR_results,1:4),
check.attributes=FALSE, check.names=FALSE,info="test1")
expect_equal(phe_dsr(test_DSR_multiarea, count, pop,
type="full", stdpop = esp2013, multiplier=10000),
slice(test_DSR_results,1:4),
check.attributes=FALSE, check.names=FALSE,info="test1")
phe_dsr(test_DSR_multiarea, count, pop, type="full", stdpop = esp2013, multiplier=10000)
slice(test_DSR_results,1:3)
expect_equal(phe_dsr(test_DSR_multiarea, count, pop, type="full", stdpop = esp2013, multiplier=10000),
slice(test_DSR_results,1:3),
check.attributes=FALSE, check.names=FALSE,info="test1")
expect_equal(data.frame(phe_dsr(test_DSR_multiarea, count, pop, type="full", stdpop = esp2013, multiplier=10000)),
slice(test_DSR_results,1:3),
check.attributes=FALSE, check.names=FALSE,info="test1")
?expect_equal
expect_equal(data.frame(phe_dsr(test_DSR_multiarea, count, pop, type="full", stdpop = esp2013, multiplier=10000)),
slice(test_DSR_results,1:3),
check.attributes=FALSE, check.names=FALSE,info="test1", na.rm=FALSE)
expect_equal(data.frame(phe_dsr(test_DSR_multiarea, count, pop, type="full", stdpop = esp2013, multiplier=10000)),
slice(test_DSR_results,1:3),
check.attributes=FALSE, check.names=FALSE,info="test1", na.rm=TRUE)
data.frame(phe_dsr(test_DSR_multiarea, count, pop,
type="full", stdpop = esp2013, multiplier=10000)
)
slice(test_DSR_results,1:3)
slice(test_DSR_results,5:7)
data.frame(phe_dsr(test_DSR_multiarea, count, pop,
type="full", stdpop = esp2013, multiplier=10000, conf.level=0.998))
data.frame(phe_dsr(test_DSR_1976, count, pop,
type="full", stdpop = test_DSR_1976$stdpop)
)
data.frame(phe_dsr(test_DSR_1976, count, pop,
type="full", stdpop = test_DSR_1976$stdpop))
slice(test_DSR_results,4)
select(slice(test_DSR_results,4),2:8]
select(slice(test_DSR_results,4),2:8)
phe_dsr(test_DSR_multiarea, count, pop, esp2013)
phe_rate(test_Rate_100_input,Numerator,Denominator)
test_Rate_100_input <- test_Rate_100[1:4]
test_Rate_100_input
phe_rate(test_Rate_100_input,Numerator,Denominator)
phe_rate(test_Rate_100_input,Numerator,Denominator, type = "full", conf.level=0.98, multiplier = 10000)
prop <- data.frame(area = c("Area1","Area2","Area3"), numerator = c(65,82,100), denominator = c(100,100,100))
prop
phe_proportion(prop, numerator, denominator)
phe_proportion(prop, numerator, denominator, type="full")
prop
test_DSR_multiarea
View(test_DSR_multiarea)
phe_dsr(test_DSR_multiarea, count, pop, esp2013)
phe_dsr(test_DSR_1976, count, pop, type="full", stdpop = test_DSR_1976$stdpop, multiplier=10000)
Y2015 <- test_DSR_multiarea %>%
mutate(Yr=2015)
Y2016 <- test_DSR_multiarea %>%
mutate(Yr=2016,
count = count + 10)
MultiGroups <- bind_rows(Y2015,Y2016)
phe_dsr(MultiGroups, count, pop, esp2013)
MultiGroups2 <- MultiGroups %>%
group_by(area, Yr)
phe_dsr(MultiGroups2, count, pop, esp2013)
phe_dsr(MultiGroups2, count, pop, esp2013, type="full")
esp2013
df <- phe_dsr(MultiGroups2, count, pop, esp2013, type="full")
View(df)
prop <- data.frame(area = c("Area1","Area2","Area3"), numerator = c(125,82,100), denominator = c(100,100,100))
prop
phe_proportion(prop, x= numerator, n= denominator)
View(test_DSR_multiarea)
?phe_dsr
