confidence = paste(confidence*100,"%",sep=""),
#              statistic = paste("rate per",format(multiplier, scientific=F)),
method  = if_else((!!x) < 10, "Exact","Byars"))
if (type == "lower") {
phe_rate <- phe_rate %>%
select(-rate, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_rate <- phe_rate %>%
select(-rate, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_rate<- phe_rate %>%
select(-lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_rate <- phe_rate %>%
select( -confidence, -method)
}
return(phe_rate)
}
phe_rate(df,Numerator, Denominator, type="standard")
?doubleValue.ToString
??doubleValue.ToString
doubleValue.ToString(100000)
multiplier <- 100000
multiplier.ToString(100000)
(0.000000005).ToString()
data.ToString("100000")
data.ToString(100000)
as.character(100000)
?as.character
# create function to calculate rate and CIs using Byar's method
phe_rate <- function(data,x, n, type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)) {
stop("function phe_dsr requires at least 3 arguments: data, x, n")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate rate and CIs
phe_rate <- data %>%
mutate(rate = (!!x)/(!!n)*multiplier,
lowercl = if_else((!!x) < 10, qchisq((1-confidence)/2,2*(!!x))/2/(!!n)*multiplier,
byars_lower((!!x),confidence)/(!!n)*multiplier),
uppercl = if_else((!!x) < 10, qchisq(confidence+(1-confidence)/2,2*(!!x)+2)/2/(!!n)*multiplier,
byars_upper((!!x),confidence)/(!!n)*multiplier),
confidence = paste(confidence*100,"%",sep=""),
statistic = paste("rate per",as.character(format(multiplier, scientific=F))),
method  = if_else((!!x) < 10, "Exact","Byars"))
if (type == "lower") {
phe_rate <- phe_rate %>%
select(-rate, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_rate <- phe_rate %>%
select(-rate, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_rate<- phe_rate %>%
select(-lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_rate <- phe_rate %>%
select( -confidence, -statistic, -method)
}
return(phe_rate)
}
phe_rate(df,Numerator, Denominator, type="standard")
phe_rate(df,Numerator, Denominator)
phe_rate(df,Numerator, Denominator, type="full")
# create function to calculate rate and CIs using Byar's method
phe_rate <- function(data,x, n, type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)) {
stop("function phe_dsr requires at least 3 arguments: data, x, n")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate rate and CIs
phe_rate <- data %>%
mutate(rate = (!!x)/(!!n)*multiplier,
lowercl = if_else((!!x) < 10, qchisq((1-confidence)/2,2*(!!x))/2/(!!n)*multiplier,
byars_lower((!!x),confidence)/(!!n)*multiplier),
uppercl = if_else((!!x) < 10, qchisq(confidence+(1-confidence)/2,2*(!!x)+2)/2/(!!n)*multiplier,
byars_upper((!!x),confidence)/(!!n)*multiplier),
confidence = paste(confidence*100,"%",sep=""),
statistic = paste("rate per",as.character(format(multiplier, scientific=F))),
method  = if_else((!!x) < 10, "Exact","Byars"))
if (type == "lower") {
phe_rate <- phe_rate %>%
select(-rate, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_rate <- phe_rate %>%
select(-rate, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_rate<- phe_rate %>%
select(-lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_rate <- phe_rate %>%
select( -confidence, -statistic, -method)
}
return(phe_rate)
}
expect_equal(phe_rate(slice(test_Rate,1:8)[1:3],Numerator,Denominator),
select(slice(test_Rate,1:8),1:6),check.attributes=FALSE, check.names=FALSE, info="test default")
phe_rate(slice(test_Rate,1:8)[1:3],Numerator,Denominator)
select(slice(test_Rate,1:8),1:6)
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator),
select(slice(test_Rate,9:16),1:6),check.attributes=FALSE, check.names=FALSE, info="test default")
phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator)
select(slice(test_Rate,9:16),1:6)
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="full"),
select(slice(test_Rate,9:16),1:9),check.attributes=FALSE, check.names=FALSE, info="test full")
phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="full")
select(slice(test_Rate,9:16),1:9)
test_Rate <- read_excel(".\\tests\\testthat\\testdata_Rate.xlsx", sheet="testdata_Rate", col_names=TRUE)
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="full"),
select(slice(test_Rate,9:16),1:9),check.attributes=FALSE, check.names=FALSE, info="test full")
phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="full")
select(slice(test_Rate,9:16),1:9)
expect_equal(phe_rate(slice(test_Rate,25:32)[1:3],Numerator,Denominator, confidence=99.8),
select(slice(test_Rate,25:32),1:6),check.attributes=FALSE, check.names=FALSE, info="test confidence")
phe_rate(slice(test_Rate,25:32)[1:3],Numerator,Denominator, confidence=99.8)
select(slice(test_Rate,25:32),1:6)
View(test_Rate)
phe_rate(slice(test_Rate,1:8)[1:3],Numerator,Denominator, multiplier=100)
select(slice(test_Rate,1:8),1:6)
phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="value")
select(slice(test_Rate,9:16),1:4)
phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="lower")
select(slice(test_Rate,9:16),1:3,5)
phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="upper")
select(slice(test_Rate,9:16),1:3,6)
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs),
"numerators must be greater than or equal to zero", info="error test 1")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs),
"function phe_dsr requires at least 3 arguments: data, x, n", info="error test 1")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(-65,80,30),
pop =c(100,100,100)), obs),
"numerators must be greater than or equal to zero", info="error num < 0")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(-65,80,30),
pop =c(100,100,100)), obs, pop),
"numerators must be greater than or equal to zero", info="error num < 0")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,0)), obs, pop),
"denominators must be greater than zero", info="error denom = 0")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,-100,100)), obs, pop),
"denominators must be greater than zero", info="error denom < 0")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs, pop, confidence = 9998),
"confidence level must be between 90 and 100 or between 0.9 and 1", info="error confidence >100")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs, pop, confidence = 40),
"confidence level must be between 90 and 100 or between 0.9 and 1", info="error confidence between 1 and 90")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs, pop, type="combined"),
"type must be one of value, lower, upper, standard or full", info="error invalid type")
expect_error(phe_rate(data.frame(area=c("Area1","Area2","Area3"),
obs =c(65,80,30),
pop =c(100,100,100)), obs, pop, type=combined),
"type must be one of value, lower, upper, standard or full", info="error invalid type")
#test calculations
test_that("rates and CIs calculate correctly",{
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator),
select(slice(test_Rate,9:16),1:6),check.attributes=FALSE, check.names=FALSE, info="test default")
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="full"),
select(slice(test_Rate,9:16),1:9),check.attributes=FALSE, check.names=FALSE, info="test full")
expect_equal(phe_rate(slice(test_Rate,25:32)[1:3],Numerator,Denominator, confidence=99.8),
select(slice(test_Rate,25:32),1:6),check.attributes=FALSE, check.names=FALSE, info="test confidence")
expect_equal(phe_rate(slice(test_Rate,1:8)[1:3],Numerator,Denominator, multiplier=100),
select(slice(test_Rate,1:8),1:6),check.attributes=FALSE, check.names=FALSE, info="test multiplier")
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="value"),
select(slice(test_Rate,9:16),1:4),check.attributes=FALSE, check.names=FALSE, info="test value")
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="lower"),
select(slice(test_Rate,9:16),1:3,5),check.attributes=FALSE, check.names=FALSE, info="test lower")
expect_equal(phe_rate(slice(test_Rate,9:16)[1:3],Numerator,Denominator, type="upper"),
select(slice(test_Rate,9:16),1:3,6),check.attributes=FALSE, check.names=FALSE, info="test upper")
})
test_Mean         <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean",         col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean_results", col_names=TRUE)
test_Mean_Grp <- group(test_Mean,Area)
library(dplyr)
test_Mean         <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean",         col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean_results", col_names=TRUE)
test_Mean_Grp <- group(test_Mean,Area)
test_Mean_Grp <- group_by(test_Mean,Area)
View(test_Mean)
test_Mean_Grp <- group_by(test_Mean,area)
# create phe_proportion function to execute binom.confint with method fixed to wilson
phe_mean <- function(data, x, type = "standard", confidence=0.95) {
# check required arguments present
if (missing(data)|missing(x)) {
stop("function phe_dsr requires at least 2 arguments: data, x")
}
# apply quotes
x <- enquo(x)
# validate arguments - copied from proportion need editing
if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
p <- (1 - confidence) / 2
# calculate proportion and CIs
phe_mean <- data %>%
summarise(value_sum   = sum(!!x),
value_count = length(!!x),
stdev   = sd(!!x)) %>%
mutate(mean = value_sum / value_count,
lowercl = mean - abs(qt(p, value_count - 1)) * stdev / sqrt(value_count),
uppercl = mean + abs(qt(p, value_count - 1)) * stdev / sqrt(value_count),
# if need norm method ?             lowercl2 = mean - NormMean((!!x),(!!n),confidence),
# if need norm method ?             uppercl2 = mean + NormMean((!!x),(!!n),confidence),
confidence = paste(confidence*100,"%",sep=""),
statistic = "mean",
method  = "Student's t-distribution")
if (type == "lower") {
phe_mean <- phe_mean %>%
select(-value_sum, -value_count, -stdev, -mean, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_mean <- phe_mean %>%
select(-value_sum, -value_count, -stdev, -mean, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_mean <- phe_mean %>%
select(-value_sum, -value_count, -stdev, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_mean <- phe_mean %>%
select(-value_sum, -value_count, -stdev, -confidence, -statistic, -method)
}
return(phe_mean)
}
View(test_Mean)
phe_mean(test_Mean,values)
View(test_Mean_results)
select(slice(test_Mean_results,1:3),4,6,7)
select(slice(test_Mean_results,3),4,6,7)
expect_equal(phe_mean(test_Mean,values),
select(slice(test_Mean_results,3),4,6,7),check.attributes=FALSE, check.names=FALSE,info="test default")
phe_mean(test_Mean_Grp,values)
select(slice(test_Mean_results,1:2),4,6,7)
select(slice(test_Mean_results,1:2),1,4,6,7)
phe_mean(test_Mean_Grp,values, type="full")
test_Mean         <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean",         col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean_results", col_names=TRUE)
test_Mean_Grp <- group_by(test_Mean,area)
test_Mean         <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean",         col_names=TRUE)
test_Mean_results <- read_excel(".\\tests\\testthat\\testdata_Mean.xlsx", sheet="testdata_Mean_results", col_names=TRUE)
test_Mean_Grp <- group_by(test_Mean,area)
phe_mean(test_Mean_Grp,values, type="full")
slice(test_Mean_results,1:2)
phe_mean(test_Mean_Grp,values, type="value")
select(slice(test_Mean_results,1:2),1,5)
phe_mean(test_Mean_Grp,values, confidence = 99.8)
select(slice(test_Mean_results,4:5),1,4,6,7)
select(slice(test_Mean_results,4:5),1,5:7)
phe_mean(test_Mean_Grp,values, confidence = 99.8)
expect_error(phe_mean(test_Mean),
"function phe_dsr requires at least 2 arguments: data, x",info="error invalid number of arguments")
test_that("means - errors are generated when invalid arguments are used",{
expect_error(phe_mean(test_Mean),
"function phe_dsr requires at least 2 arguments: data, x",info="error invalid number of arguments")
expect_error(phe_mean(test_Mean, values, confidence = 0.2),
"function phe_dsr requires at least 2 arguments: data, x",info="error confidence < 0.9")
expect_error(phe_mean(test_Mean, values, confidence = 202),
"function phe_dsr requires at least 2 arguments: data, x",info="error confidence between 1 and 90")
expect_error(phe_mean(test_Mean, values, confidence = 200),
"function phe_dsr requires at least 2 arguments: data, x",info="error confidence > 100")
expect_error(phe_mean(test_Mean, values, type="combined"),
"type must be one of value, lower, upper, standard or full",info="error invalid type")
})
#test error handling
test_that("means - errors are generated when invalid arguments are used",{
expect_error(phe_mean(test_Mean),
"function phe_dsr requires at least 2 arguments: data, x",info="error invalid number of arguments")
expect_error(phe_mean(test_Mean, values, confidence = 0.2),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence < 0.9")
expect_error(phe_mean(test_Mean, values, confidence = 202),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence between 1 and 90")
expect_error(phe_mean(test_Mean, values, confidence = 200),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence > 100")
expect_error(phe_mean(test_Mean, values, type="combined"),
"type must be one of value, lower, upper, standard or full",info="error invalid type")
})
#test calculations
test_that("means and CIs calculate correctly",{
expect_equal(phe_mean(test_Mean,values),
select(slice(test_Mean_results,3),5:7),check.attributes=FALSE, check.names=FALSE,info="test default")
expect_equal(phe_mean(test_Mean_Grp,values),
select(slice(test_Mean_results,1:2),1,5:7),check.attributes=FALSE, check.names=FALSE,info="test default grouped")
expect_equal(phe_mean(test_Mean_Grp,values, type="full"),
slice(test_Mean_results,1:2),check.attributes=FALSE, check.names=FALSE,info="test full")
expect_equal(phe_mean(test_Mean_Grp,values, type="value"),
select(slice(test_Mean_results,1:2),1,5),check.attributes=FALSE, check.names=FALSE,info="test value")
expect_equal(phe_mean(test_Mean_Grp,values, type="lower"),
select(slice(test_Mean_results,1:2),1,6),check.attributes=FALSE, check.names=FALSE,info="test lower")
expect_equal(phe_mean(test_Mean_Grp,values, type="upper"),
select(slice(test_Mean_results,1:2),1,7),check.attributes=FALSE, check.names=FALSE,info="test upper")
expect_equal(phe_mean(test_Mean_Grp,values, confidence = 99.8),
select(slice(test_Mean_results,4:5),1,5:7),check.attributes=FALSE, check.names=FALSE,info="test confidence")
})
test_DSR_results   <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",        col_names=TRUE)
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(summarise(data,n=n()),n)) != 1) {
stop("data must contain the same number of rows for each group")
} else if (!exists("stdpop", where=data)) {
if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%",sep=""),
statistic = paste("dsr per",format(multiplier,scientific=F)),
method = if_else(total_count < 10,"NA","Dobson"))
phe_dsr$dsr[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
phe_dsr(test_DSR_multiarea, count, pop, stdpop = esp2013)
View(test_DSR_results)
select(slice(test_DSR_results,1:3),1,4:6)
test_DSR_results   <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",        col_names=TRUE)
select(slice(test_DSR_results,1:3),1,4:6)
phe_dsr(test_DSR_multiarea, count, pop, stdpop = esp2013)
test_DSR_results   <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",        col_names=TRUE)
expect_equal(phe_dsr(test_DSR_multiarea, count, pop, stdpop = esp2013),
select(slice(test_DSR_results,1:3),1,4:6),
check.attributes=FALSE, check.names=FALSE,info="test default")
phe_dsr(test_DSR_1976, count, pop, stdpop = stdpop)
select(slice(test_DSR_results,4),1,4:6)
phe_dsr(test_DSR_1976, count, pop, stdpop = test_DSR_1976$stdpop)
select(slice(test_DSR_results,4),4:6)
expect_equal(phe_dsr(test_DSR_1976, count, pop, stdpop = stdpop),
select(slice(test_DSR_results,4),4:6),
check.attributes=FALSE, check.names=FALSE,info="test default with own stdpop by col name")
esp2013
phe_dsr(test_DSR_multiarea, count, pop,
stdpop = c(5000, 5500, 5500, 5500, 6000, 6000, 6500, 7000, 7000, 7000, 7000, 6500, 6000, 5500, 5000, 4000, 2500, 1500, 1000))
select(slice(test_DSR_results,1:3),1,4:6)
test_DSR_results   <- read_excel(".\\tests\\testthat\\testdata_DSR.xlsx", sheet="testresults",        col_names=TRUE)
phe_dsr(test_DSR_multiarea, count, pop, stdpop = esp2013)
select(slice(test_DSR_results,1:3),1,4:6)
phe_dsr(test_DSR_multiarea, count, pop, stdpop = esp2013, type="full")
select(slice(test_DSR_results,1:3),1:9)
# define the DSR function
phe_dsr <- function(data, x, n, stdpop, type = "standard", confidence = 0.95, multiplier = 100000) {
# check required arguments present
if (missing(data)|missing(x)|missing(n)|missing(stdpop)) {
stop("function phe_dsr requires at least 4 arguments: data, x, n, stdpop")
}
# apply quotes
x <- enquo(x)
n <- enquo(n)
enquostdpop <- enquo(stdpop)
# validate arguments
if (any(pull(data, !!x) < 0)) {
stop("numerators must all be greater than or equal to zero")
} else if (any(pull(data, !!n) <= 0)) {
stop("denominators must all be greater than zero")
} else if ((confidence<0.9)|(confidence >1 & confidence <90)|(confidence > 100)) {
stop("confidence level must be between 90 and 100 or between 0.9 and 1")
} else if (!(type %in% c("value", "lower", "upper", "standard", "full"))) {
stop("type must be one of value, lower, upper, standard or full")
} else if (n_distinct(select(summarise(data,n=n()),n)) != 1) {
stop("data must contain the same number of rows for each group")
} else if (!exists("stdpop", where=data)) {
if (pull(slice(select(summarise(data,n=n()),n),1)) != length(stdpop)) {
stop("stdpop length must equal number of rows in each group within data")
}
}
# scale confidence level
if (confidence >= 90) {
confidence <- confidence/100
}
# calculate DSR and CIs
phe_dsr <- data %>%
mutate(wt_rate = (!!x) * (!!enquostdpop) / (!!n),
sq_rate = (!!x) * ((!!enquostdpop)/(!!n))^2) %>%
summarise(total_count = sum(!!x),
total_pop = sum(!!n),
dsr = sum(wt_rate) / sum((!!enquostdpop)) * multiplier,
vardsr = 1/sum(!!enquostdpop)^2 * sum(sq_rate),
lowercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_lower(sum(!!x),confidence)-sum(!!x)) * multiplier,
uppercl = dsr + sqrt((vardsr/sum(!!x)))*(byars_upper(sum(!!x),confidence)-sum(!!x)) * multiplier) %>%
select(-vardsr) %>%
mutate(confidence = paste(confidence*100,"%",sep=""),
statistic = paste("dsr per",format(multiplier,scientific=F)),
method = "Dobson")
phe_dsr$dsr[phe_dsr$total_count < 10]        <- "NA - total count is < 10"
phe_dsr$uppercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
phe_dsr$lowercl[phe_dsr$total_count < 10]    <- "NA - total count is < 10"
if (type == "lower") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -uppercl, -confidence, -statistic, -method)
} else if (type == "upper") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -dsr, -lowercl, -confidence, -statistic, -method)
} else if (type == "value") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -lowercl, -uppercl, -confidence, -statistic, -method)
} else if (type == "standard") {
phe_dsr <- phe_dsr %>%
select(-total_count, -total_pop, -confidence, -statistic, -method)
}
return(phe_dsr)
}
phe_dsr(test_DSR_multiarea, count, pop, stdpop = esp2013, type="full")
select(slice(test_DSR_results,9:11),1:9)
phe_dsr(test_DSR_multiarea, count, pop, stdpop = esp2013, type="value")
select(slice(test_DSR_results,9:11),1:5)
select(slice(test_DSR_results,9:11),1,4)
select(slice(test_DSR_results,9:11),1,5)
select(slice(test_DSR_results,9:11),1,6)
phe_dsr(test_DSR_multiarea, count, pop, stdpop = esp2013, confidence = 0.98)
select(slice(test_DSR_results,13:15),1,4:6)
phe_dsr(test_DSR_multiarea, count, pop, stdpop = esp2013, confidence = 0.998)
phe_dsr(test_DSR_multiarea, count, pop, stdpop = esp2013, multiplier=10000)
select(slice(test_DSR_results,1:3),1,4:6)
expect_error(phe_dsr(test_DSR_multiarea, count, pop),
"function phe_dsr requires at least 4 arguments: data, x, n, stdpop",info="error test 1")
expect_error(phe_dsr(test_DSR_err1, count, pop, stdpop = esp2013),
"numerators must all be greater than or equal to zero",info="error test 1")
expect_error(phe_dsr(test_DSR_multiarea, count, pop, stdpop = esp2013, confidence = 3),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence between 1 and 90")
expect_error(phe_dsr(test_DSR_multiarea, count, pop, stdpop = esp2013, confidence = 1000),
"confidence level must be between 90 and 100 or between 0.9 and 1",info="error confidence >100")
